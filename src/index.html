<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="AI Browser - Modern web browser with intelligent features">
    <title>AI Browser</title>
    <link rel="stylesheet" href="index.css">
    <!-- Markdown parser -->
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
</head>
<body>
    <div class="browser-container" role="application" aria-label="AI Browser">
        <!-- Hover trigger zone for collapsed sidebar -->
        <div class="hover-trigger-zone" id="hoverTriggerZone"></div>
        <!-- Left Tab Rail -->
        <aside class="tab-rail" aria-label="Tab Sidebar">
            <div class="tab-rail-header">
                <div class="incognito-indicator" id="incognitoIndicator" style="display: none;" title="Incognito Mode - Your browsing history won't be saved">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <!-- Sunglasses icon for incognito -->
                        <circle cx="7" cy="10" r="4" fill="currentColor" opacity="0.2"/>
                        <circle cx="17" cy="10" r="4" fill="currentColor" opacity="0.2"/>
                        <path d="M11 10h2"/>
                        <path d="M3 14c0 2 1.5 3 4 3h10c2.5 0 4-1 4-3"/>
                    </svg>
                    <span class="incognito-text">Incognito</span>
                </div>
            </div>
            <div class="rail-url">
                <div class="rail-url-controls">
                    <button class="nav-btn" id="backBtn" title="Go back (⌘←)" aria-label="Navigate back">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M19 12H5" />
                            <path d="M12 5l-7 7 7 7" />
                        </svg>
                    </button>
                    <button class="nav-btn" id="forwardBtn" title="Go forward (⌘→)" aria-label="Navigate forward">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M5 12h14" />
                            <path d="M12 5l7 7-7 7" />
                        </svg>
                    </button>
                    <button class="nav-btn" id="refreshBtn" title="Refresh page (⌘R)" aria-label="Refresh current page">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <polyline points="23 4 23 10 17 10" />
                            <polyline points="1 20 1 14 7 14" />
                            <path d="M3.51 9a9 9 0 0114.13-3.36L23 10" />
                            <path d="M20.49 15a9 9 0 01-14.13 3.36L1 14" />
                        </svg>
                    </button>
                    <button class="chat-btn" id="chatBtn" title="AI Chat (⌘E)" aria-label="Open AI Chat">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M21 15a2 2 0 01-2 2H7l-4 4V5a2 2 0 012-2h14a2 2 0 012 2z" />
                        </svg>
                    </button>
                    <button class="summarize-btn" id="summarizeBtn" title="Summarize Page" aria-label="Summarize current page">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <line x1="21" y1="6" x2="8" y2="6" />
                            <line x1="21" y1="12" x2="8" y2="12" />
                            <line x1="21" y1="18" x2="8" y2="18" />
                            <line x1="3" y1="6" x2="3" y2="6" />
                            <line x1="3" y1="12" x2="3" y2="12" />
                            <line x1="3" y1="18" x2="3" y2="18" />
                        </svg>
                    </button>
                </div>
                <div class="url-input-wrapper">
                    <input type="url" 
                           class="url-bar" 
                           id="urlBar" 
                           placeholder="Search or enter website URL..."
                           aria-label="Address bar"
                           autocomplete="url"
                           spellcheck="false">
                    <button class="copy-url-btn" id="copyUrlBtn" title="Copy URL (⌘⇧C)" aria-label="Copy current URL">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                            <path d="M5 15H4a2 2 0 01-2-2V4a2 2 0 012-2h9a2 2 0 012 2v1"></path>
                        </svg>
                    </button>
                    <div class="url-suggestions" id="urlSuggestions" role="listbox" aria-label="URL suggestions"></div>
                </div>
                <div class="rail-url-actions">
                </div>
            </div>
            <button class="rail-new-tab-pill" id="railNewTabBtn" title="New Tab (⌘T)" aria-label="Open new tab">
                <span class="plus">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M12 4v16M20 12H4" />
                    </svg>
                </span>
                <span style="font-weight:600;">New Tab</span>
            </button>
            <div class="tab-rail-tabs" id="tabRailTabs" role="listbox" aria-label="Open Tabs"></div>
            <div class="sidebar-resizer tab-rail-resizer" id="tabRailResizer" role="separator" aria-orientation="vertical" aria-label="Resize tab sidebar" tabindex="0"></div>
        </aside>
        <!-- Hidden top tab bar kept only as logical container for existing code -->
        <div class="tab-bar" role="tablist" aria-label="Browser tabs" style="display:none">
            <div class="tabs-container" id="tabsContainer"></div>
        </div>

        <!-- AI Chat Sidebar -->
        <aside class="chat-sidebar" id="chatSidebar" role="complementary" aria-label="AI Chat Sidebar">
            <div class="sidebar-resizer chat-sidebar-resizer" id="chatSidebarResizer" role="separator" aria-orientation="vertical" aria-label="Resize AI chat sidebar" tabindex="0"></div>
            <div class="chat-history" id="chatHistory" tabindex="0" aria-live="polite" aria-atomic="false"></div>
            <div class="chat-input-area">
                <div id="contextPillsContainer" class="context-pills-container"></div>
                <form class="chat-input-container" id="chatInputForm" autocomplete="off">
                    <button type="button" class="chat-clear-btn" id="chatClearBtn" aria-label="Clear chat" title="Clear chat">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M3 6h18" />
                            <path d="M8 6v12a2 2 0 002 2h4a2 2 0 002-2V6" />
                            <line x1="10" y1="11" x2="14" y2="11" />
                            <line x1="10" y1="15" x2="14" y2="15" />
                        </svg>
                    </button>
                    <div class="chat-input-wrapper">
                        <input id="chatInput" class="chat-input" type="text" placeholder="Ask AI..." aria-label="Chat input" />
                        <div id="tabSuggestions" class="tab-suggestions"></div>
                    </div>
                    <button type="submit" class="chat-send-btn" id="chatSendBtn" aria-label="Send message">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <line x1="22" y1="2" x2="11" y2="13" />
                            <polygon points="22 2 15 22 11 13 2 9 22 2" />
                        </svg>
                    </button>
                </form>
            </div>
        </aside>

        <!-- Web Content Area -->
        <main class="content-area" id="contentArea" role="main" aria-label="Web content">
            <!-- Loading state -->
            <div class="loading-state" id="loadingState" style="display: none;">
                <div class="loading-indicator">
                    <div class="loading-spinner" aria-hidden="true"></div>
                    <span>Loading page...</span>
                </div>
            </div>
            
            <!-- Error state -->
            <div class="error-state" id="errorState" style="display: none;">
                <div class="error-page">
                    <svg width="48" height="48" viewBox="0 0 24 24" fill="var(--color-text-tertiary)" aria-hidden="true">
                        <path d="M12 9v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"/>
                    </svg>
                    <h2>Unable to load page</h2>
                    <p>Please check your internet connection and try again.</p>
                    <button class="retry-btn" id="retryBtn">Try Again</button>
                </div>
            </div>
            
            <!-- Web views will be dynamically added here -->
        </main>
    </div>

    <!-- Command Palette -->
    <div class="command-palette-backdrop" id="commandPaletteBackdrop">
        <div class="command-palette">
            <div class="command-palette-input-container">
                <div class="command-palette-mode-switcher">
                    <button class="command-palette-mode-btn active" id="commandPaletteModeSearch" data-mode="search">
                        <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <circle cx="11" cy="11" r="8"></circle>
                            <path d="M21 21l-4.35-4.35"></path>
                        </svg>
                        Search
                    </button>
                    <button class="command-palette-mode-btn" id="commandPaletteModeAsk" data-mode="ask">
                        <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M21 15a2 2 0 01-2 2H7l-4 4V5a2 2 0 012-2h14a2 2 0 012 2z"></path>
                        </svg>
                        Ask
                    </button>
                </div>
                <div class="command-palette-input-wrapper">
                    <textarea 
                        class="command-palette-input" 
                        id="commandPaletteInput" 
                        placeholder="Search or Enter URL..."
                        autocomplete="off"
                        spellcheck="false"
                        rows="1"
                    ></textarea>
                    <div class="command-palette-autocomplete" id="commandPaletteAutocomplete"></div>
                </div>
            </div>
            <div class="command-palette-results" id="commandPaletteResults"></div>
            <div class="command-palette-response" id="commandPaletteResponse" style="display: none;">
                <div class="command-palette-response-content" id="commandPaletteResponseContent"></div>
            </div>
        </div>
    </div>

    <script>
        class BrowserManager {
            constructor() {
                this.tabs = [];
                this.activeTabId = null;
                this.tabCounter = 0;
                this.saveTabsTimeout = null; // For debouncing tab saves
                this.sidebarConstraints = {
                    tabRail: { min: 200, max: 420, default: 260 },
                    chatSidebar: { min: 260, max: 560, default: 320 }
                };
                this.activeResize = null;
                this.resizeAnimationFrame = null;
                this.rootStyle = document.documentElement.style;
                this.handleSidebarResize = this.handleSidebarResize.bind(this);
                this.stopSidebarResize = this.stopSidebarResize.bind(this);
                this.sidebarCollapsed = false;
                this.sidebarHoveredWhileCollapsed = false;
                this.history = []; // Browser history for suggestions
                this.closedTabs = []; // Recently closed tabs for reopening
                this.maxClosedTabHistory = 25;
                this.partition = null; // Cache partition to avoid async calls
                
                this.initializeElements();
                this.setupResizableSidebars();
                this.setupEventListeners();
                this.setupKeyboardShortcuts();
                this.chatSessions = new Map();
                this.marked = window.marked;
                
                this.updateActionButtonsVisibility();
                
                // Initialize partition and incognito mode before creating initial tab
                this.initializePartition()
                    .then(() => this.loadPersistedChats())
                    .then(() => this.createInitialTab())
                    .catch((error) => {
                        console.error('Error during startup initialization:', error);
                    });
                
                // Load history for command palette suggestions
                this.loadHistory();
                
            }
            
            async initializePartition() {
                try {
                    // Show incognito indicator if in incognito mode
                    await this.checkIncognitoMode();
                    // Cache partition synchronously for future use
                    this.partition = await window.electronAPI.getPartition();
                    console.log('Partition initialized:', this.partition);
                } catch (error) {
                    console.error('Error initializing partition:', error);
                    // Fallback to default partition
                    this.partition = 'persist:browser';
                }
            }

            async loadPersistedChats() {
                if (!window.electronAPI || typeof window.electronAPI.loadChats !== 'function') {
                    return;
                }

                // Skip loading chats when running in incognito mode
                if (this.isIncognito) {
                    this.chatSessions.clear();
                    return;
                }

                try {
                    const storedChats = await window.electronAPI.loadChats();
                    if (storedChats && typeof storedChats === 'object') {
                        Object.entries(storedChats).forEach(([chatId, chatData]) => {
                            if (chatData && Array.isArray(chatData.session)) {
                                const restoredSession = chatData.session.map((msg) => ({
                                    ...msg
                                }));
                                this.chatSessions.set(chatId, restoredSession);
                            }
                        });
                    }
                } catch (error) {
                    console.error('Error loading saved chats:', error);
                }
            }
            
            async checkIncognitoMode() {
                console.log('Checking incognito mode...');
                try {
                    const isIncognitoMode = await window.electronAPI.isIncognito();
                    console.log('isIncognito result:', isIncognitoMode);
                    
                    // Cache the incognito state
                    this.isIncognito = isIncognitoMode;
                    
                    if (isIncognitoMode && this.incognitoIndicator) {
                        console.log('Showing incognito indicator');
                        this.incognitoIndicator.style.display = 'flex';
                        // Update window title to show incognito mode
                        document.title = 'AI Browser (Incognito)';
                    } else {
                        console.log('NOT showing incognito indicator. isIncognito:', isIncognitoMode, 'indicator exists:', !!this.incognitoIndicator);
                    }
                } catch (error) {
                    console.error('Error checking incognito mode:', error);
                    this.isIncognito = false;
                }
            }
            
            showSettings() {
                // Create new tab with settings
                this.createTab('settings.html');
            }
            
            getDisplayUrl(url) {
                return url || '';
            }

            getFriendlyTabTitle(tab) {
                if (!tab) {
                    return 'Untitled tab';
                }

                const title = (tab.title || '').trim();
                const url = tab.url || '';

                // Prefer explicit titles that are not file paths
                if (title && !title.startsWith('file://')) {
                    return title;
                }

                // Map special pages to human-friendly labels
                if (url.includes('newtab.html')) {
                    return 'AI Chat';
                }
                if (url.includes('history.html')) {
                    return 'History';
                }
                if (url.includes('settings.html')) {
                    return 'Settings';
                }

                if (url) {
                    try {
                        const parsed = new URL(url);
                        if (parsed.protocol === 'file:') {
                            const segments = parsed.pathname.split('/').filter(Boolean);
                            const fileName = segments.pop();
                            if (fileName) {
                                return fileName;
                            }
                        }
                    } catch (err) {
                        // ignore
                    }
                }

                if (title) {
                    return title;
                }

                return url || 'Untitled tab';
            }

            isAIChatUrl(url) {
                return typeof url === 'string' && url.includes('newtab.html');
            }

            updateActionButtonsVisibility(url = '') {
                const shouldHide = this.isAIChatUrl(url);
                const displayValue = shouldHide ? 'none' : 'flex';
                if (this.chatBtn) {
                    this.chatBtn.style.display = displayValue;
                }
                if (this.summarizeBtn) {
                    this.summarizeBtn.style.display = displayValue;
                }
            }

            injectLinkHandlerScript(webview) {
                try {
                    // Inject script to handle middle click and Ctrl+Click
                    webview.executeJavaScript(`
                        (function() {
                            // Check if already injected to avoid duplicate handlers
                            if (window.__linkHandlerInjected) return;
                            window.__linkHandlerInjected = true;
                            
                            console.log('Link handler script injected');
                            
                            // Capture mousedown event FIRST to intercept middle-click before any other handlers
                            document.addEventListener('mousedown', function(e) {
                                // Middle click (button === 1)
                                if (e.button === 1) {
                                    const link = e.target.closest('a');
                                    if (link && link.href && !link.href.startsWith('javascript:')) {
                                        console.log('Middle-click detected on link:', link.href);
                                        e.preventDefault();
                                        e.stopPropagation();
                                        e.stopImmediatePropagation();
                                        
                                        // Try to use electronAPI if available
                                        if (window.electronAPI && window.electronAPI.openLinkInNewTab) {
                                            window.electronAPI.openLinkInNewTab(link.href);
                                        }
                                        return false;
                                    }
                                    // Prevent middle click scrolling on non-links
                                    e.preventDefault();
                                    return false;
                                }
                            }, true); // Use capture phase for early interception
                            
                            // Also handle click events for Ctrl/Cmd+Click
                            document.addEventListener('click', function(e) {
                                // Ctrl+Click or Cmd+Click
                                if ((e.ctrlKey || e.metaKey) && e.button === 0) {
                                    const link = e.target.closest('a');
                                    if (link && link.href && !link.href.startsWith('javascript:')) {
                                        console.log('Ctrl+Click detected on link:', link.href);
                                        e.preventDefault();
                                        e.stopPropagation();
                                        e.stopImmediatePropagation();
                                        
                                        if (window.electronAPI && window.electronAPI.openLinkInNewTab) {
                                            window.electronAPI.openLinkInNewTab(link.href);
                                        }
                                        return false;
                                    }
                                }
                            }, true); // Use capture phase
                        })();
                    `);
                } catch (err) {
                    console.error('Error injecting link handler:', err);
                }
            }

            initializeElements() {
                this.tabsContainer = document.getElementById('tabsContainer');
                this.newTabBtn = document.getElementById('railNewTabBtn');
                this.tabRailTabs = document.getElementById('tabRailTabs');
                this.railNewTabBtn = document.getElementById('railNewTabBtn');
                this.backBtn = document.getElementById('backBtn');
                this.forwardBtn = document.getElementById('forwardBtn');
                this.refreshBtn = document.getElementById('refreshBtn');
                this.urlBar = document.getElementById('urlBar');
                this.contentArea = document.getElementById('contentArea');
                this.loadingState = document.getElementById('loadingState');
                this.errorState = document.getElementById('errorState');
                this.retryBtn = document.getElementById('retryBtn');
                // References for showing/hiding the URL bar portion on the new-tab page
                this.navBar = document.querySelector('.nav-bar');
                this.urlBarContainer = document.querySelector('.url-bar-container');
                this.chatBtn = document.getElementById('chatBtn');
                this.summarizeBtn = document.getElementById('summarizeBtn');
                this.copyUrlBtn = document.getElementById('copyUrlBtn');
                this.chatSidebar = document.getElementById('chatSidebar');
                this.chatInput = document.getElementById('chatInput');
                this.chatInputForm = document.getElementById('chatInputForm');
                this.chatHistory = document.getElementById('chatHistory');
                this.chatClearBtn = document.getElementById('chatClearBtn');
                this.contextPillsContainer = document.getElementById('contextPillsContainer');
                this.tabSuggestions = document.getElementById('tabSuggestions');
                this.tabRailResizer = document.getElementById('tabRailResizer');
                this.chatSidebarResizer = document.getElementById('chatSidebarResizer');
                this.tabRail = document.querySelector('.tab-rail');
                this.hoverTriggerZone = document.getElementById('hoverTriggerZone');
                this.incognitoIndicator = document.getElementById('incognitoIndicator');
                // Command palette elements
                this.commandPaletteBackdrop = document.getElementById('commandPaletteBackdrop');
                this.commandPalette = document.querySelector('.command-palette');
                this.commandPaletteInput = document.getElementById('commandPaletteInput');
                this.commandPaletteAutocomplete = document.getElementById('commandPaletteAutocomplete');
                this.commandPaletteResults = document.getElementById('commandPaletteResults');
                this.commandPaletteResponse = document.getElementById('commandPaletteResponse');
                this.commandPaletteResponseContent = document.getElementById('commandPaletteResponseContent');
                this.commandPaletteModeSearch = document.getElementById('commandPaletteModeSearch');
                this.commandPaletteModeAsk = document.getElementById('commandPaletteModeAsk');
                this.commandPaletteMode = 'search'; // Default mode
                this.selectedResultIndex = -1;
                this.currentResults = []; // Store current results for autocomplete
                this.isNavigatingResults = false; // Flag to prevent input reset during navigation
                this.autocompleteText = ''; // Current autocomplete suggestion
                this.activeCommandPaletteRequest = null; // Track active Ask mode request

                // Listen for IPC messages from main process
                window.electronAPI.onShowSettings(() => {
                    this.showSettings();
                });
                
                // Listen for messages from webviews
                window.addEventListener('message', (e) => {
                    console.log('BrowserManager received message:', e.data);
                    console.log('BrowserManager received message from source:', e.source);
                    if (!e.data || !e.data.type) return;

                    // Handle shortcut messages from newtab.html
                    if (e.data.type === 'shortcut') {
                        switch (e.data.command) {
                            case 'close-tab':
                                this.closeActiveTab();
                                break;
                            case 'new-tab':
                                this.createTab();
                                break;
                            case 'focus-url':
                                if (!this.urlBarContainer || this.urlBarContainer.style.display !== 'none') {
                                    this.urlBar.focus();
                                }
                                break;
                        }
                    }

                    // Handle tab context requests from newtab.html
                    if (e.data.type === 'request-tabs') {
                        // Try to find sender by contentWindow; if not found, fall back to active newtab
                        let sourceWebview = this.tabs.find(tab => tab.webview && tab.webview.contentWindow === e.source);
                        if (!sourceWebview) {
                            sourceWebview = this.tabs.find(tab => tab.id === this.activeTabId && tab.url && tab.url.includes('newtab.html'));
                        }
                        if (sourceWebview) {
                            const tabData = this.tabs
                                .filter(t => t.id !== sourceWebview.id)
                                .map(t => ({ id: t.id, title: t.title, url: t.url }));

                        try {
                            // Send message to guest via IPC channel bridged by preload
                            sourceWebview.webview.send('guest-message', { type: 'tabs-response', tabs: tabData });
                        } catch (err) {
                            console.error('Failed to send tabs response:', err);
                        }
                        }
                    }

                    // Handle chat requests from newtab.html
                    if (e.data.type === 'new-tab-chat-send') {
                        console.log('Received new-tab-chat-send message:', e.data);
                        console.log('Handling new-tab-chat-send with data:', e.data);
                        // Find the source webview by checking if it contains newtab.html
                        const sourceWebview = this.tabs.find(tab => 
                            tab.url && tab.url.includes('newtab.html') && tab.id === this.activeTabId
                        );
                        if (sourceWebview) {
                            console.log('Found source webview, calling handleNewTabChat');
                            console.log('Source webview found:', sourceWebview.id);
                            this.handleNewTabChat(e.data, sourceWebview);
                        } else {
                            console.error('Could not find source webview for chat request');
                        }
                    }
                });
            }

            setupResizableSidebars() {
                if (!this.rootStyle) {
                    this.rootStyle = document.documentElement.style;
                }

                const savedTabRailWidth = this.getStoredSidebarWidth('tabRailWidth');
                if (savedTabRailWidth !== null) {
                    this.setTabRailWidth(savedTabRailWidth, false);
                }

                const savedChatSidebarWidth = this.getStoredSidebarWidth('chatSidebarWidth');
                if (savedChatSidebarWidth !== null) {
                    this.setChatSidebarWidth(savedChatSidebarWidth, false);
                }

                // Restore collapsed state from localStorage
                const savedCollapsedState = localStorage.getItem('sidebarCollapsed');
                if (savedCollapsedState === 'true') {
                    this.sidebarCollapsed = true;
                    this.tabRail.classList.add('collapsed');
                    this.hoverTriggerZone.classList.add('active');
                }

                if (this.tabRailResizer) {
                    this.tabRailResizer.addEventListener('pointerdown', (event) => this.startSidebarResize('tabRail', event));
                    this.tabRailResizer.addEventListener('keydown', (event) => this.handleResizerKeydown('tabRail', event));
                }

                if (this.chatSidebarResizer) {
                    this.chatSidebarResizer.addEventListener('pointerdown', (event) => this.startSidebarResize('chatSidebar', event));
                    this.chatSidebarResizer.addEventListener('keydown', (event) => this.handleResizerKeydown('chatSidebar', event));
                }

                // Setup hover behavior for collapsed sidebar
                if (this.hoverTriggerZone && this.tabRail) {
                    let collapseTimeout = null;

                    const showHoverSidebar = () => {
                        if (!this.sidebarCollapsed) return;
                        this.tabRail.classList.add('overlay-visible');
                        this.updateFocusModeVisualState(true);
                    };

                    const hideHoverSidebar = () => {
                        if (!this.sidebarCollapsed) return;
                        if (collapseTimeout) {
                            clearTimeout(collapseTimeout);
                            collapseTimeout = null;
                        }
                        this.tabRail.classList.remove('overlay-visible');
                        this.updateFocusModeVisualState();
                    };
                    
                    this.hoverTriggerZone.addEventListener('mouseenter', () => {
                        if (this.sidebarCollapsed) {
                            this.sidebarHoveredWhileCollapsed = true;
                            showHoverSidebar();
                        }
                    });

                    this.tabRail.addEventListener('mouseleave', () => {
                        if (this.sidebarCollapsed && this.sidebarHoveredWhileCollapsed) {
                            // Add a small delay before hiding to prevent flickering
                            collapseTimeout = setTimeout(() => {
                                this.sidebarHoveredWhileCollapsed = false;
                                hideHoverSidebar();
                            }, 180);
                        }
                    });

                    this.tabRail.addEventListener('mouseenter', () => {
                        // Cancel collapse if user moves back into sidebar
                        if (collapseTimeout) {
                            clearTimeout(collapseTimeout);
                            collapseTimeout = null;
                        }
                    });
                }

                this.updateContentAreaWidth();
                this.updateFocusModeVisualState();
            }

            getStoredSidebarWidth(key) {
                try {
                    const stored = localStorage.getItem(key);
                    if (stored) {
                        const parsed = parseInt(stored, 10);
                        if (!Number.isNaN(parsed)) {
                            return parsed;
                        }
                    }
                } catch (error) {
                    console.warn('Failed to read stored sidebar width:', error);
                }
                return null;
            }

            startSidebarResize(sidebar, event) {
                if (event.button !== undefined && event.button !== 0) return;
                event.preventDefault();
                const clientX = event.clientX;
                if (typeof clientX !== 'number') return;

                document.body.classList.add('sidebar-resizing');

                const initialWidth = this.getCurrentSidebarWidth(sidebar);
                this.activeResize = {
                    sidebar,
                    startX: clientX,
                    initialWidth,
                    lastWidth: initialWidth,
                    handleElement: event.currentTarget
                };

                if (this.activeResize.handleElement) {
                    this.activeResize.handleElement.classList.add('dragging');
                    if (event.pointerId != null && this.activeResize.handleElement.setPointerCapture) {
                        try {
                            this.activeResize.handleElement.setPointerCapture(event.pointerId);
                        } catch (_) {}
                    }
                }

                document.addEventListener('pointermove', this.handleSidebarResize);
                document.addEventListener('pointerup', this.stopSidebarResize);
                document.addEventListener('pointercancel', this.stopSidebarResize);
            }

            handleSidebarResize(event) {
                if (!this.activeResize) return;
                event.preventDefault();
                const clientX = event.clientX;
                if (typeof clientX !== 'number') return;

                // Cancel any pending animation frame
                if (this.resizeAnimationFrame) {
                    cancelAnimationFrame(this.resizeAnimationFrame);
                }

                // Schedule resize update for next animation frame
                this.resizeAnimationFrame = requestAnimationFrame(() => {
                    let newWidth = this.activeResize.initialWidth;
                    if (this.activeResize.sidebar === 'tabRail') {
                        newWidth = this.clampWidth(
                            this.activeResize.initialWidth + (clientX - this.activeResize.startX),
                            this.sidebarConstraints.tabRail.min,
                            this.sidebarConstraints.tabRail.max
                        );
                        this.setTabRailWidth(newWidth, false);
                    } else {
                        newWidth = this.clampWidth(
                            this.activeResize.initialWidth + (this.activeResize.startX - clientX),
                            this.sidebarConstraints.chatSidebar.min,
                            this.sidebarConstraints.chatSidebar.max
                        );
                        this.setChatSidebarWidth(newWidth, false);
                    }

                    this.activeResize.lastWidth = newWidth;
                    this.resizeAnimationFrame = null;
                });
            }

            stopSidebarResize(event) {
                if (!this.activeResize) return;

                // Cancel any pending animation frame
                if (this.resizeAnimationFrame) {
                    cancelAnimationFrame(this.resizeAnimationFrame);
                    this.resizeAnimationFrame = null;
                }

                const finalWidth = this.activeResize.lastWidth;

                if (typeof finalWidth === 'number') {
                    if (this.activeResize.sidebar === 'tabRail') {
                        this.setTabRailWidth(finalWidth);
                    } else {
                        this.setChatSidebarWidth(finalWidth);
                    }
                }

                if (this.activeResize.handleElement) {
                    this.activeResize.handleElement.classList.remove('dragging');
                    if (event && event.pointerId != null && this.activeResize.handleElement.releasePointerCapture) {
                        try {
                            this.activeResize.handleElement.releasePointerCapture(event.pointerId);
                        } catch (_) {}
                    }
                }

                this.activeResize = null;
                document.removeEventListener('pointermove', this.handleSidebarResize);
                document.removeEventListener('pointerup', this.stopSidebarResize);
                document.removeEventListener('pointercancel', this.stopSidebarResize);

                document.body.classList.remove('sidebar-resizing');
            }

            handleResizerKeydown(sidebar, event) {
                if (event.key !== 'ArrowLeft' && event.key !== 'ArrowRight') return;
                const step = event.shiftKey ? 20 : 10;

                if (sidebar === 'tabRail') {
                    const delta = event.key === 'ArrowLeft' ? -step : step;
                    this.setTabRailWidth(this.getCurrentSidebarWidth('tabRail') + delta);
                } else {
                    const delta = event.key === 'ArrowLeft' ? step : -step;
                    this.setChatSidebarWidth(this.getCurrentSidebarWidth('chatSidebar') + delta);
                }

                event.preventDefault();
            }

            setTabRailWidth(width, persist = true) {
                const clamped = this.clampWidth(
                    width,
                    this.sidebarConstraints.tabRail.min,
                    this.sidebarConstraints.tabRail.max
                );

                if (this.rootStyle) {
                    this.rootStyle.setProperty('--tab-rail-width', `${clamped}px`);
                }

                if (persist) {
                    this.persistSidebarWidth('tabRailWidth', clamped);
                    // Only update content area when persisting (not during active resize)
                    this.updateContentAreaWidth();
                }

                return clamped;
            }

            setChatSidebarWidth(width, persist = true) {
                const clamped = this.clampWidth(
                    width,
                    this.sidebarConstraints.chatSidebar.min,
                    this.sidebarConstraints.chatSidebar.max
                );

                if (this.rootStyle) {
                    this.rootStyle.setProperty('--chat-sidebar-width', `${clamped}px`);
                }

                if (persist) {
                    this.persistSidebarWidth('chatSidebarWidth', clamped);
                    // Only update content area when persisting (not during active resize)
                    this.updateContentAreaWidth();
                }

                return clamped;
            }

            persistSidebarWidth(key, value) {
                try {
                    localStorage.setItem(key, String(value));
                } catch (error) {
                    console.warn('Failed to persist sidebar width:', error);
                }
            }

            getCurrentSidebarWidth(sidebar) {
                const varName = sidebar === 'tabRail' ? '--tab-rail-width' : '--chat-sidebar-width';
                const constraints = sidebar === 'tabRail' ? this.sidebarConstraints.tabRail : this.sidebarConstraints.chatSidebar;
                const computed = getComputedStyle(document.documentElement).getPropertyValue(varName);
                const parsed = parseInt(computed, 10);
                if (!Number.isNaN(parsed)) {
                    return parsed;
                }
                return constraints.default;
            }

            clampWidth(value, min, max) {
                return Math.min(Math.max(value, min), max);
            }

            updateContentAreaWidth() {
                // Width is now handled by CSS :has() selectors based on chat-sidebar.open class
                // No need to set inline styles which cause layout thrashing
            }

            toggleSidebarCollapse() {
                this.sidebarCollapsed = !this.sidebarCollapsed;
                
                if (this.sidebarCollapsed) {
                    this.tabRail.classList.add('collapsed');
                    this.tabRail.classList.remove('overlay-visible');
                    if (this.hoverTriggerZone) {
                        this.hoverTriggerZone.classList.add('active');
                    }
                } else {
                    this.tabRail.classList.remove('collapsed');
                    this.tabRail.classList.remove('overlay-visible');
                    if (this.hoverTriggerZone) {
                        this.hoverTriggerZone.classList.remove('active');
                    }
                    this.sidebarHoveredWhileCollapsed = false;
                }
                
                // Persist state to localStorage
                localStorage.setItem('sidebarCollapsed', this.sidebarCollapsed.toString());
                
                this.updateContentAreaWidth();
                this.updateFocusModeVisualState();
            }

            updateFocusModeVisualState(forceVisible = false) {
                if (!window.electronAPI || typeof window.electronAPI.setWindowButtonsVisible !== 'function') {
                    return;
                }

                const shouldShow = forceVisible || !this.sidebarCollapsed;

                window.electronAPI
                    .setWindowButtonsVisible(shouldShow)
                    .catch((error) => {
                        console.warn('Failed to update window buttons visibility:', error);
                    });
            }

            async handleNewTabChat(data, sourceTab) {
                console.log('handleNewTabChat called with:', data);
                console.log('handleNewTabChat starting for reqId:', data.reqId);
                const { reqId, session, referencedTabIds } = data;
                const contexts = [];

                for (const tabId of referencedTabIds) {
                    const referencedTab = this.tabs.find(t => t.id === tabId);
                    if (referencedTab) {
                        try {
                            const context = await this.getPageContext(referencedTab);
                            if (context) {
                                console.log('Got context for tab:', tabId);
                                contexts.push(context);
                            }
                        } catch (err) {
                            console.error(`Failed to get page context for tab ${tabId}:`, err);
                        }
                    }
                }

                console.log('Sending chat request with contexts:', contexts.length);
                console.log('Sending to electronAPI.sendChat');
                const streamHandler = (streamData) => {
                    console.log('Received stream data:', streamData);
                    console.log('Stream handler called with:', streamData);
                    // Only handle responses for this request and forward to the source webview
                    if (streamData.id === reqId) {
                        // Forward streamed chat data to the webview
                        try {
                            const payload = { type: 'chat-stream-response', ...streamData };
                            console.log('Forwarding stream to webview via send(channel):', payload);
                            sourceTab.webview.send('guest-message', payload);
                        } catch (err) {
                            console.error('Failed to send message to webview via send:', err);
                        }
                        
                        if (streamData.done || streamData.error) {
                            // Clean up listener after completion or error
                            console.log('Stream done or error, removing listener');
                            window.electronAPI.removeListener('chat-stream', streamHandler);
                        }
                    }
                };

                // Ensure we don't have duplicate listeners; add before sending to avoid race
                console.log('Adding chat-stream listener');
                window.electronAPI.onChatStream(streamHandler);

                try {
                    // Enable web search for ask section
                    const webSearchOptions = {
                        enableWebSearch: true,
                        model: 'gpt-5',
                        externalWebAccess: true
                    };
                    // Fire and forget so we don't miss early tokens
                    window.electronAPI.sendChat(reqId, session, contexts, webSearchOptions);
                } catch (error) {
                    console.error('Error sending chat request:', error);
                    // Send error back to newtab immediately
                    try {
                        sourceTab.webview.send('guest-message', { type: 'chat-stream-response', id: reqId, error: error.message });
                    } catch (e2) {
                        console.error('Failed to send error to guest:', e2);
                    }
                }
            }

            setupEventListeners() {
                // Tab management - show command palette instead of creating tab directly
                this.newTabBtn.addEventListener('click', () => this.showCommandPalette());
                
                // Navigation
                this.backBtn.addEventListener('click', () => this.navigateBack());
                this.forwardBtn.addEventListener('click', () => this.navigateForward());
                this.refreshBtn.addEventListener('click', () => this.refreshPage());
                this.retryBtn.addEventListener('click', () => this.refreshPage());
                
                // Command palette event listeners
                this.commandPaletteBackdrop.addEventListener('click', (e) => {
                    if (e.target === this.commandPaletteBackdrop) {
                        this.hideCommandPalette();
                    }
                });
                
                this.commandPaletteModeSearch.addEventListener('click', () => {
                    this.setCommandPaletteMode('search');
                });
                
                this.commandPaletteModeAsk.addEventListener('click', () => {
                    this.setCommandPaletteMode('ask');
                });
                
                this.commandPaletteInput.addEventListener('input', () => {
                    this.adjustCommandPaletteInputHeight();
                    // Reset selection when user types (but not when navigating with arrow keys)
                    if (!this.isNavigatingResults) {
                        this.selectedResultIndex = -1;
                        this.updateCommandPaletteResults();
                    }
                });
                
                this.commandPaletteInput.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        // If a result is selected, execute that specific result
                        if (this.selectedResultIndex >= 0 && this.currentResults.length > 0) {
                            const selectedResult = this.currentResults[this.selectedResultIndex];
                            this.executeSelectedResult(selectedResult);
                        } else {
                            this.executeCommandPaletteAction();
                        }
                    } else if (e.key === 'Escape') {
                        e.preventDefault();
                        this.hideCommandPalette();
                    } else if (e.key === 'ArrowDown') {
                        e.preventDefault();
                        this.selectNextResult();
                    } else if (e.key === 'ArrowUp') {
                        e.preventDefault();
                        this.selectPreviousResult();
                    } else if (e.key === 'Tab' && e.shiftKey) {
                        e.preventDefault();
                        // Shift+Tab switches between Search and Ask modes
                        const newMode = this.commandPaletteMode === 'search' ? 'ask' : 'search';
                        this.setCommandPaletteMode(newMode);
                    } else if (e.key === 'Tab') {
                        e.preventDefault();
                        // Accept autocomplete if available
                        if (this.autocompleteText) {
                            this.commandPaletteInput.value = this.autocompleteText;
                            this.hideAutocomplete();
                            // Move cursor to end
                            setTimeout(() => {
                                this.commandPaletteInput.setSelectionRange(this.autocompleteText.length, this.autocompleteText.length);
                            }, 0);
                        }
                    } else if (e.key === 'ArrowRight') {
                        // Accept autocomplete with right arrow if available
                        if (this.autocompleteText && this.commandPaletteInput.selectionStart === this.commandPaletteInput.value.length) {
                            e.preventDefault();
                            this.commandPaletteInput.value = this.autocompleteText;
                            this.hideAutocomplete();
                            // Move cursor to end
                            setTimeout(() => {
                                this.commandPaletteInput.setSelectionRange(this.autocompleteText.length, this.autocompleteText.length);
                            }, 0);
                        }
                    }
                });
                
                // URL bar
                this.urlBar.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        this.navigateToUrl();
                    }
                });

                // URL bar text selection with improved UX
                this.urlBar.addEventListener('focus', () => {
                    this.urlBar.select();
                });

                // Enhanced click behavior
                this.urlBar.addEventListener('click', (e) => {
                    if (this.urlBar.selectionStart === this.urlBar.selectionEnd) {
                        this.urlBar.select();
                    }
                });

                // Chat button
                if (this.chatBtn) {
                    this.chatBtn.addEventListener('click', () => {
                        if (!this.canToggleChatSidebar()) {
                            return;
                        }
                        this.toggleChatSidebar();
                    });
                }

                // Summarize button
                if (this.summarizeBtn) {
                    this.summarizeBtn.addEventListener('click', () => this.handleSummarizePage());
                }

                // Copy URL button
                if (this.copyUrlBtn) {
                    this.copyUrlBtn.addEventListener('click', () => this.copyCurrentUrl());
                }

                // Chat form submission
                if (this.chatInputForm) {
                    this.chatInputForm.addEventListener('submit', (e) => {
                        e.preventDefault();
                        this.handleChatSend();
                    });
                }
                if (this.chatClearBtn) {
                    this.chatClearBtn.addEventListener('click', () => this.clearChat());
                }

                this.chatInput.addEventListener('input', () => this.handleChatInput());
                this.chatInput.addEventListener('keydown', (e) => this.handleSuggestionKeyboardNav(e));
                this.tabSuggestions.addEventListener('click', (e) => this.handleSuggestionClick(e));

                // Electron menu shortcuts
                // From menu/global accelerator
                window.electronAPI.onNewTab(() => {
                    this.showCommandPalette();
                });
                window.electronAPI.onCloseTab(() => this.closeActiveTab());
                window.electronAPI.onReopenClosedTab(() => this.reopenLastClosedTab());
                window.electronAPI.onNavigateBack(() => this.navigateBack());
                window.electronAPI.onNavigateForward(() => this.navigateForward());
                window.electronAPI.onRefreshPage(() => this.refreshPage());
                // Global accelerators that must work when webview is focused
                window.electronAPI.onFocusUrl(() => {
                    if (!this.urlBarContainer || this.urlBarContainer.style.display !== 'none') {
                        this.urlBar.focus();
                    }
                });
                window.electronAPI.onToggleChat(() => {
                    if (!this.canToggleChatSidebar()) {
                        return;
                    }
                    this.toggleChatSidebar();
                });
                window.electronAPI.onToggleSidebar(() => this.toggleSidebarCollapse());
                // Tab numeric selection from menu accelerators
                window.electronAPI.onSelectTab(({ index }) => this.selectTabByNumber(index));
                window.electronAPI.onShowHistory(() => this.showHistory());
                window.electronAPI.onCopyCurrentUrl(() => this.copyCurrentUrl());
                window.electronAPI.onUrlCopied((url) => this.showToast('URL copied to clipboard'));

                // Listen for IPC messages to open links in tabs
                window.electronAPI.onOpenInTab((url) => {
                    console.log('Received open-in-tab IPC:', url);
                    this.createTab(url);
                });

                // Tab context menu event listeners
                window.electronAPI.onTabMuted(({ tabId }) => this.handleTabMuted(tabId));
                window.electronAPI.onDuplicateTab(({ tabId }) => this.handleDuplicateTab(tabId));
                window.electronAPI.onPinTab(({ tabId }) => this.handlePinTab(tabId));
                window.electronAPI.onCloseTabById(({ tabId }) => this.closeTab(tabId));

                // Window resize handling
                window.addEventListener('resize', this.debounce(() => {
                    this.updateLayout();
                }, 250));
            }

            setupKeyboardShortcuts() {
                document.addEventListener('keydown', (e) => {
                    // Handle keyboard shortcuts
                    if (e.metaKey || e.ctrlKey) {
                        const key = e.key.toLowerCase();
                        if (key === 't') {
                            e.preventDefault();
                            if (e.shiftKey) {
                                this.reopenLastClosedTab();
                            } else {
                                this.showCommandPalette();
                            }
                            return;
                        }

                        switch (key) {
                            case 'w':
                                e.preventDefault();
                                this.closeActiveTab();
                                break;
                            case 'r':
                                e.preventDefault();
                                this.refreshPage();
                                break;
                            case 'l':
                                e.preventDefault();
                                this.urlBar.focus();
                                break;
                            case 'e':
                                e.preventDefault();
                                if (this.canToggleChatSidebar()) {
                                    this.toggleChatSidebar();
                                }
                                break;
                            case 's':
                                e.preventDefault();
                                this.toggleSidebarCollapse();
                                break;
                            case 'y':
                                e.preventDefault();
                                this.showHistory();
                                break;
                            case 'c':
                                if (e.shiftKey) {
                                    e.preventDefault();
                                    this.copyCurrentUrl();
                                }
                                break;
                            case ',':
                                e.preventDefault();
                                this.showSettings();
                                break;
                            default: {
                                // Number keys 1-9 to switch tabs like Chrome
                                if (/^[1-9]$/.test(key)) {
                                    e.preventDefault();
                                    this.selectTabByNumber(parseInt(key, 10));
                                }
                                break;
                            }
                        }
                    }
                });
            }


            selectTabByNumber(n) {
                if (!this.tabs.length) return;
                // Chrome behavior: 1-8 go to that index; 9 goes to last tab
                let targetIndex = n === 9 ? this.tabs.length - 1 : n - 1;
                if (targetIndex < 0) targetIndex = 0;
                if (targetIndex >= this.tabs.length) return; // Ignore if beyond tab count (except 9 handled above)
                const targetTab = this.tabs[targetIndex];
                if (targetTab) this.switchToTab(targetTab.id);
            }

            debounce(func, wait) {
                let timeout;
                return function executedFunction(...args) {
                    const later = () => {
                        clearTimeout(timeout);
                        func(...args);
                    };
                    clearTimeout(timeout);
                    timeout = setTimeout(later, wait);
                };
            }

            updateLayout() {
                // Handle any layout updates needed on resize
                this.tabs.forEach(tab => {
                    if (tab.webview) {
                        // Webviews automatically handle resize
                    }
                });
            }

            // Show or hide the navigation bar depending on the active URL
            updateNavBarVisibility(url) {
                if (!this.urlBarContainer) return;
                // URL bar now lives in the sidebar and should stay visible
                this.urlBarContainer.style.display = 'flex';
            }

            async createTab(url = 'https://www.google.com', restoredId = null, restoredTitle = null, restoredState = null) {
                const preloadPath = await window.electronAPI.getPreloadPath();
                console.log('createTab called with url:', url);
                // Use restored ID if provided, otherwise generate new one
                const tabId = restoredId || `tab-${++this.tabCounter}`;
                if (restoredId) {
                    // Ensure counter is higher than restored ID to avoid conflicts
                    const idNum = parseInt(tabId.replace('tab-', '')) || 0;
                    if (idNum >= this.tabCounter) {
                        this.tabCounter = idNum + 1;
                    }
                }
                
                // Create tab object
                const tab = {
                    id: tabId,
                    url: url,
                    title: restoredTitle || 'New Tab',
                    webview: null,
                    isLoading: false,
                    isAiChatSurface: false,
                    chatSidebarOpen: false, // Track chat sidebar state per tab
                    referencedTabs: new Set(), // Store IDs of all context tabs
                    railElement: null,
                    railTitle: null,
                    railFavicon: null,
                    tabCloseBtn: null,
                    railCloseBtn: null,
                    isMuted: restoredState?.isMuted || false, // Track mute state
                    isPinned: restoredState?.isPinned || false, // Track pin state
                    pinnedHomeUrl: restoredState?.pinnedHomeUrl ?? (restoredState?.isPinned ? url : null),
                };

                // Create enhanced tab UI with better accessibility
                const tabElement = document.createElement('div');
                tabElement.className = 'tab';
                tabElement.setAttribute('data-tab-id', tabId);
                tabElement.setAttribute('role', 'tab');
                tabElement.setAttribute('aria-selected', 'false');
                tabElement.setAttribute('tabindex', '-1');
                
                const tabTitle = document.createElement('span');
                tabTitle.className = 'tab-title';
                tabTitle.textContent = restoredTitle || 'New Tab';
                tabTitle.setAttribute('aria-label', 'Tab title');
                tab.tabTitle = tabTitle;
                
                const tabFavicon = document.createElement('img');
                tabFavicon.className = 'tab-favicon';
                tabFavicon.alt = '';
                
                // Helper to create loading indicator favicon
                const getLoadingFavicon = () => {
                    // Detect dark mode
                    const isDarkMode = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
                    const circleColor = isDarkMode ? '#6B7280' : '#9CA3AF'; // Gray-500 for dark, Gray-400 for light
                    
                    // Simple circle loading indicator
                    return 'data:image/svg+xml,' + encodeURIComponent(`
                        <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
                            <circle cx="8" cy="8" r="6" stroke="${circleColor}" stroke-width="1.5" fill="none" opacity="0.6"/>
                            <circle cx="8" cy="8" r="3" fill="${circleColor}" opacity="0.4"/>
                        </svg>
                    `);
                };
                
                // Set loading indicator as initial favicon
                tabFavicon.src = getLoadingFavicon();
                
                // Helper to set AI logo for newtab.html
                const setAIIcon = () => {
                    // Detect dark mode
                    const isDarkMode = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
                    const iconColor = isDarkMode ? '#60A5FA' : '#2563EB'; // Blue-400 for dark, Blue-600 for light
                    
                    // AI sparkle icon - represents AI intelligence
                    const aiIconSVG = 'data:image/svg+xml,' + encodeURIComponent(`
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 2L13.5 8.5L20 10L13.5 11.5L12 18L10.5 11.5L4 10L10.5 8.5L12 2Z" fill="${iconColor}"/>
                        </svg>
                    `);
                    tabFavicon.src = aiIconSVG;
                    if (tab.railFavicon) tab.railFavicon.src = aiIconSVG;
                };
                
                // Helper to set favicon through fallback when direct event missing
                const updateFaviconFallback = async () => {
                    try {
                        // Try to find <link rel="icon"> inside the page
                        const candidate = await webview.executeJavaScript(`(() => {
                            const relIcons = Array.from(document.querySelectorAll('link[rel~="icon"]'));
                            if (relIcons.length) return relIcons[0].href || null;
                            return null;
                        })()`, true);
                        let iconUrl = candidate;
                        if (iconUrl) {
                            // Resolve relative paths
                            if (iconUrl.startsWith('/')) {
                                try {
                                    iconUrl = new URL(iconUrl, webview.getURL()).href;
                                } catch (err) {}
                            }
                            tabFavicon.src = iconUrl;
                            if (tab.railFavicon) tab.railFavicon.src = iconUrl;
                        } else {
                            // Check if this is newtab.html and use AI icon
                            const currentUrl = webview.getURL();
                            if (currentUrl && currentUrl.includes('newtab.html')) {
                                setAIIcon();
                            } else {
                                // Use Google favicon service as final fallback
                                try {
                                    const pageOrigin = new URL(webview.getURL()).origin;
                                    const fallback = `https://www.google.com/s2/favicons?sz=32&domain_url=${encodeURIComponent(pageOrigin)}`;
                                    tabFavicon.src = fallback;
                                    if (tab.railFavicon) tab.railFavicon.src = fallback;
                                } catch (err) {}
                            }
                        }
                    } catch (err) {
                        console.error('Failed to fetch favicon via fallback:', err);
                    }
                };

                const closeBtn = document.createElement('button');
                closeBtn.className = 'tab-close-btn';
                closeBtn.setAttribute('aria-label', 'Close tab');
                closeBtn.setAttribute('title', 'Close tab (⌘W)');
                closeBtn.innerHTML = `
                    <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <line x1="18" y1="6" x2="6" y2="18" />
                        <line x1="6" y1="6" x2="18" y2="18" />
                    </svg>
                `;
                closeBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    this.closeTab(tabId);
                });
                tab.tabCloseBtn = closeBtn;

                tabElement.appendChild(tabTitle);
                tabElement.appendChild(tabFavicon);
                // Ensure favicon appears before the title for better UX
                if (tabElement.contains(tabTitle)) {
                    tabElement.insertBefore(tabFavicon, tabTitle);
                }
                tabElement.appendChild(closeBtn);
                
                tabElement.addEventListener('click', () => this.switchToTab(tabId));
                tabElement.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter' || e.key === ' ') {
                        e.preventDefault();
                        this.switchToTab(tabId);
                    }
                });
                
                this.tabsContainer.appendChild(tabElement);

                // Create matching item in the left rail
                if (this.tabRailTabs) {
                    const railElement = document.createElement('div');
                    railElement.className = 'rail-tab';
                    railElement.setAttribute('data-tab-id', tabId);
                    railElement.setAttribute('role', 'option');
                    railElement.setAttribute('aria-selected', 'false');

                    const railFavicon = document.createElement('img');
                    railFavicon.className = 'rail-favicon';
                    railFavicon.alt = '';
                    // Set loading indicator as initial favicon
                    railFavicon.src = getLoadingFavicon();
                    tab.railFavicon = railFavicon;

                    const railTitle = document.createElement('span');
                    railTitle.className = 'rail-title';
                    railTitle.textContent = restoredTitle || 'New Tab';
                    tab.railTitle = railTitle;

                    const railCloseBtn = document.createElement('button');
                    railCloseBtn.className = 'rail-close-btn';
                    railCloseBtn.setAttribute('aria-label', 'Close tab');
                    railCloseBtn.setAttribute('title', 'Close tab (⌘W)');
                    railCloseBtn.innerHTML = `
                        <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <line x1="18" y1="6" x2="6" y2="18" />
                            <line x1="6" y1="6" x2="18" y2="18" />
                        </svg>
                    `;
                    railCloseBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        this.closeTab(tabId);
                    });
                    tab.railCloseBtn = railCloseBtn;

                    railElement.appendChild(railFavicon);
                    railElement.appendChild(railTitle);
                    railElement.appendChild(railCloseBtn);

                    railElement.addEventListener('click', () => this.switchToTab(tabId));
                    railElement.addEventListener('keydown', (e) => {
                        if (e.key === 'Enter' || e.key === ' ') {
                            e.preventDefault();
                            this.switchToTab(tabId);
                        }
                    });

                    // Add context menu event listener
                    railElement.addEventListener('contextmenu', (e) => {
                        e.preventDefault();
                        window.electronAPI.showTabContextMenu(tabId, e.clientX, e.clientY, tab.isMuted, tab.isPinned);
                    });

                    this.tabRailTabs.appendChild(railElement);

                    tab.railElement = railElement;
                    tab.railTitle = railTitle;
                    tab.railFavicon = railFavicon;
                }

                // Create webview with enhanced loading states
                const webview = document.createElement('webview');
                webview.style.display = 'none';
                // Note: removed webview.src = url;
                // NOTE: Removed 'allowpopups' attribute - we handle new windows ourselves
                webview.setAttribute('webpreferences', 'contextIsolation=true');
                webview.setAttribute('preload', `file://${preloadPath}`);
                webview.setAttribute('useragent', 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36 AI-Browser/1.0');
                
                // Use cached partition or fetch if not available (should be cached during initialization)
                // CRITICAL: Partition MUST be set before any navigation or src attribute
                let partition = this.partition;
                if (!partition) {
                    console.warn('Partition not cached, fetching synchronously...');
                    partition = await window.electronAPI.getPartition();
                    this.partition = partition; // Cache for future use
                }
                webview.setAttribute('partition', partition);
                
                // Handle new window requests BEFORE navigation starts
                webview.addEventListener('new-window', (e) => {
                    console.log('new-window event triggered:', e.url);
                    e.preventDefault();
                    if (e.url) {
                        this.createTab(e.url);
                    }
                });
                
                // Also handle window.open calls and validate partition
                webview.addEventListener('did-attach', () => {
                    // Validate partition is set correctly
                    const actualPartition = webview.getAttribute('partition');
                    if (actualPartition !== partition) {
                        console.error(`Partition mismatch! Expected: ${partition}, Actual: ${actualPartition}`);
                    } else {
                        console.log(`Webview attached with partition: ${partition}`);
                    }
                    
                    try {
                        webview.executeJavaScript(`
                            (function() {
                                const originalOpen = window.open;
                                window.open = function(url, name, features) {
                                    console.log('window.open intercepted:', url);
                                    if (window.electronAPI && window.electronAPI.openLinkInNewTab) {
                                        window.electronAPI.openLinkInNewTab(url);
                                        return null;
                                    }
                                    return originalOpen.call(window, url, name, features);
                                };
                            })();
                        `);
                    } catch (err) {
                        console.error('Error intercepting window.open:', err);
                    }
                });
                
                const result = await window.electronAPI.navigateTo(url);
                console.log('navigateTo result:', result);
                if (result.success) {
                  tab.url = result.url;
                  if (tab.isPinned && !tab.pinnedHomeUrl) {
                      tab.pinnedHomeUrl = result.url;
                  }
                  webview.setAttribute('src', result.url); // Set src instead of loadURL
                  
                  // Set AI icon immediately for newtab.html
                  if (result.url.includes('newtab.html')) {
                      setAIIcon();
                  }
                  // Save tabs after initial navigation (debounced)
                  this.saveTabsDebounced();
                } else {
                  console.error('Navigation failed:', result.error);
                }

                // Enhanced webview event handling
                webview.addEventListener('dom-ready', () => {
                    try {
                        tab.title = webview.getTitle() || 'New Tab';
                        tabTitle.textContent = tab.title;
                        tabTitle.setAttribute('title', tab.title);
                        if (tab.railTitle) {
                            tab.railTitle.textContent = tab.title;
                            tab.railTitle.setAttribute('title', tab.title);
                        }
                        if (this.activeTabId === tabId) {
                            this.urlBar.value = this.getDisplayUrl(webview.getURL());
                            this.hideLoading();
                            this.updateActionButtonsVisibility(webview.getURL());
                        }
                        
                        // Inject link handler script when DOM is ready
                        this.injectLinkHandlerScript(webview);
                    } catch (error) {
                        console.error('Error in dom-ready handler:', error);
                    }
                });

                // Handle messages coming from newtab.html via ipcRenderer.sendToHost
                webview.addEventListener('ipc-message', (event) => {
                    try {
                        if (!event || !event.channel) return;
                        const channel = event.channel;
                        const arg = (event.args && event.args[0]) || {};
                        if (channel === 'request-tabs') {
                            const tabData = this.tabs
                                .filter(t => t.id !== tab.id)
                                .map(t => ({ id: t.id, title: t.title, url: t.url }));
                            try {
                                webview.send('guest-message', { type: 'tabs-response', tabs: tabData });
                            } catch (err) {
                                console.error('Failed to send tabs response (ipc):', err);
                            }
                        }
                        if (channel === 'new-tab-chat-send') {
                            const data = { type: 'new-tab-chat-send', ...arg };
                            this.handleNewTabChat(data, tab);
                        }
                        if (channel === 'open-link') {
                            // Handle link opening in new tab (middle click, Ctrl+Click)
                            console.log('open-link message received:', arg.url);
                            if (arg.url) {
                                this.createTab(arg.url);
                            }
                        }
                        if (channel === 'open-chat-session') {
                            this.openSavedChat(arg.chatId);
                        }
                        if (channel === 'chat-mode') {
                            tab.isAiChatSurface = arg.mode === 'ask';
                        }
                        if (channel === 'update-title') {
                            // Update tab title and URL bar when newtab sends title update
                            const newTitle = arg.title || 'New Tab';
                            tab.title = newTitle;
                            if (tab.tabTitle) {
                                tab.tabTitle.textContent = newTitle;
                                tab.tabTitle.setAttribute('title', newTitle);
                            }
                            if (tab.railTitle) {
                                tab.railTitle.textContent = newTitle;
                                tab.railTitle.setAttribute('title', newTitle);
                            }
                            if (this.activeTabId === tab.id) {
                                this.urlBar.value = newTitle;
                            }
                            // If chatId is provided, update the tab URL to use chatId instead of query
                            if (arg.chatId && tab.url.includes('newtab.html')) {
                                const newtabPath = tab.url.split('?')[0];
                                tab.url = `${newtabPath}?mode=ask&chatId=${arg.chatId}`;
                                // Save tabs with the updated URL
                                this.saveTabsDebounced();
                                if (this.activeTabId === tab.id) {
                                    this.updateActionButtonsVisibility(tab.url);
                                }
                            }
                            // Ensure AI icon is set for newtab
                            if (tab.url && tab.url.includes('newtab.html')) {
                                // Detect dark mode
                                const isDarkMode = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
                                const iconColor = isDarkMode ? '#60A5FA' : '#2563EB'; // Blue-400 for dark, Blue-600 for light
                                
                                const aiIconSVG = 'data:image/svg+xml,' + encodeURIComponent(`
                                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                                        <path d="M12 2L13.5 8.5L20 10L13.5 11.5L12 18L10.5 11.5L4 10L10.5 8.5L12 2Z" fill="${iconColor}"/>
                                    </svg>
                                `);
                                if (tab.tabFavicon) tab.tabFavicon.src = aiIconSVG;
                                if (tab.railFavicon) tab.railFavicon.src = aiIconSVG;
                            }
                        }
                        if (channel === 'shortcut') {
                            switch (arg.command) {
                                case 'close-tab':
                                    this.closeTab(tab.id);
                                    break;
                                case 'new-tab':
                                    this.showCommandPalette();
                                    break;
                                case 'focus-url':
                                    if (!this.urlBarContainer || this.urlBarContainer.style.display !== 'none') {
                                        this.urlBar.focus();
                                    }
                                    break;
                                case 'refresh-page':
                                    this.refreshPage();
                                    break;
                        case 'toggle-chat':
                            if (this.canToggleChatSidebar()) {
                                this.toggleChatSidebar();
                            }
                            break;
                        default:
                            break;
                        }
                        }
                    } catch (e) {
                        console.error('ipc-message handler error:', e);
                    }
                });

                webview.addEventListener('page-title-updated', (_event) => {
                    const newTitle = webview.getTitle() || 'New Tab';
                    tab.title = newTitle;
                    tabTitle.textContent = newTitle;
                    tabTitle.setAttribute('title', newTitle);
                    // Save tabs after title update (debounced)
                    this.saveTabsDebounced();
                    if (tab.railTitle) {
                        tab.railTitle.textContent = newTitle;
                        tab.railTitle.setAttribute('title', newTitle);
                    }
                });
                // Add listener to capture page favicon changes
                webview.addEventListener('page-favicon-updated', async (event) => {
                    if (event.favicons && event.favicons.length > 0) {
                        tabFavicon.src = event.favicons[0];
                        if (tab.railFavicon) tab.railFavicon.src = event.favicons[0];
                    } else {
                        // If favicon still empty, attempt fallback
                        await updateFaviconFallback();
                    }
                });

                webview.addEventListener('did-navigate', (e) => {
                    tab.url = e.url;
                    if (!e.url.includes('newtab.html')) {
                        tab.isAiChatSurface = false;
                    }
                    // Show loading indicator when navigating to new main page
                    tabFavicon.src = getLoadingFavicon();
                    if (tab.railFavicon) tab.railFavicon.src = getLoadingFavicon();
                    if (this.activeTabId === tabId) {
                        this.urlBar.value = this.getDisplayUrl(e.url);
                        this.updateNavBarVisibility(e.url);
                        this.updateActionButtonsVisibility(e.url);
                    }
                    // Save tabs after navigation (debounced)
                    this.saveTabsDebounced();
                });

                webview.addEventListener('did-navigate-in-page', (e) => {
                    tab.url = e.url;
                    if (!e.url.includes('newtab.html')) {
                        tab.isAiChatSurface = false;
                    }
                    // Show loading indicator for in-page navigations (e.g., SPA route changes)
                    tabFavicon.src = getLoadingFavicon();
                    if (tab.railFavicon) tab.railFavicon.src = getLoadingFavicon();
                    if (this.activeTabId === tabId) {
                        this.urlBar.value = this.getDisplayUrl(e.url);
                        this.updateNavBarVisibility(e.url);
                        this.updateActionButtonsVisibility(e.url);
                    }
                    // Save tabs after in-page navigation (debounced)
                    this.saveTabsDebounced();
                });

                webview.addEventListener('did-fail-load', (e) => {
                    console.error('Page failed to load:', e);
                    if (e.errorCode !== -3 && this.activeTabId === tabId) { 
                        this.showError();
                    }
                    tab.isLoading = false;
                });

                webview.addEventListener('did-start-loading', () => {
                    tab.isLoading = true;
                    tabTitle.textContent = 'Loading...';
                    if (tab.railTitle) tab.railTitle.textContent = 'Loading...';
                    // Removed favicon reset here to avoid flicker; handled on navigation
                    if (this.activeTabId === tabId) {
                        this.showLoading();
                    }
                });

                webview.addEventListener('did-stop-loading', async () => {
                    tab.isLoading = false;
                    const finalTitle = webview.getTitle() || tab.title;
                    tab.title = finalTitle;
                    tabTitle.textContent = finalTitle;
                    tabTitle.setAttribute('title', finalTitle);
                    if (tab.railTitle) {
                        tab.railTitle.textContent = finalTitle;
                        tab.railTitle.setAttribute('title', finalTitle);
                    }
                    // If favicon still empty, attempt fallback
                    if (!tabFavicon.src) {
                        await updateFaviconFallback();
                    }
                    
                    // Save to history
                    const currentUrl = webview.getURL();
                    if (currentUrl && currentUrl.startsWith('http')) {
                        this.saveHistoryEntry(currentUrl, finalTitle, tabFavicon.src || '');
                    }
                    
                    if (this.activeTabId === tabId) {
                        this.hideLoading();
                    }
                });

                this.contentArea.appendChild(webview);
                tab.webview = webview;
                tab.tabElement = tabElement;
                tab.tabTitle = tabTitle;
                tab.tabFavicon = tabFavicon;
                // railElement is already assigned inside the if block above

                this.tabs.push(tab);
                // Initialize empty chat session for this tab
                if (!this.chatSessions.has(tabId)) {
                    this.chatSessions.set(tabId, []);
                }

                // Apply restored states
                if (tab.isMuted && webview) {
                    // Apply mute state when webview is ready
                    webview.addEventListener('dom-ready', () => {
                        webview.setAudioMuted(true);
                    }, { once: true });
                }

                // Update visual indicators for restored states
                if (tab.isMuted || tab.isPinned) {
                    this.updateTabVisuals(tab);
                }

                // When the webview is ready, perform the full switch if it's the active tab.
                // This prevents race conditions where we try to execute JS before the page is loaded.
                webview.addEventListener('dom-ready', () => {
                    if (this.activeTabId === tabId) {
                        this.switchToTab(tabId);
                    }
                }, { once: true });

                // Always focus the newly created tab (unless restoring - in that case switchToTab will be called after all tabs are restored)
                if (!restoredId) {
                    this.switchToTab(tabId);
                } else if (tab.isPinned) {
                    // If restoring and tab is pinned, reorder tabs after all tabs are loaded
                    setTimeout(() => this.reorderTabs(), 100);
                }

                // Save tabs after creation (debounced)
                this.saveTabsDebounced();

                return tab;
            }
            
            // Debounced tab saving
            saveTabsDebounced() {
                // Clear existing timeout
                if (this.saveTabsTimeout) {
                    clearTimeout(this.saveTabsTimeout);
                }
                // Set new timeout to save after 500ms
                this.saveTabsTimeout = setTimeout(() => {
                    this.saveTabs();
                }, 500);
            }
            
            async saveTabs() {
                try {
                    // Don't save tabs in incognito mode
                    if (this.isIncognito) {
                        return;
                    }
                    // Prepare tab data for saving (only essential info)
                    const tabsData = this.tabs.map(tab => ({
                        id: tab.id,
                        url: tab.url,
                        title: tab.title || 'New Tab',
                        isMuted: tab.isMuted || false,
                        isPinned: tab.isPinned || false,
                        pinnedHomeUrl: tab.pinnedHomeUrl || null
                    }));
                    await window.electronAPI.saveTabs(tabsData, this.activeTabId);
                } catch (error) {
                    console.error('Error saving tabs:', error);
                }
            }

            showLoading() {
                this.loadingState.style.display = 'flex';
                this.errorState.style.display = 'none';
            }

            hideLoading() {
                this.loadingState.style.display = 'none';
            }

            showError() {
                this.loadingState.style.display = 'none';
                this.errorState.style.display = 'flex';
            }

            // Command Palette Methods
            async loadHistory() {
                try {
                    if (!this.isIncognito) {
                        this.history = await window.electronAPI.loadHistory();
                    }
                } catch (error) {
                    console.error('Error loading history:', error);
                    this.history = [];
                }
            }

            showCommandPalette() {
                this.commandPaletteInput.value = '';
                this.selectedResultIndex = -1;
                this.commandPaletteBackdrop.classList.add('active');
                this.updateCommandPaletteResults();
                this.adjustCommandPaletteInputHeight();
                // Use setTimeout to ensure the backdrop is visible before focusing
                setTimeout(() => {
                    this.commandPaletteInput.focus();
                }, 50);
            }

            hideCommandPalette() {
                this.commandPaletteBackdrop.classList.remove('active');
                this.commandPaletteInput.value = '';
                this.selectedResultIndex = -1;
                this.commandPaletteResults.innerHTML = '';
                this.hideAutocomplete();
                if (this.commandPaletteInput) {
                    this.commandPaletteInput.style.height = '';
                }

                // Cancel any active streaming request
                if (this.activeCommandPaletteRequest) {
                    window.electronAPI.cancelChat(this.activeCommandPaletteRequest);
                    this.activeCommandPaletteRequest = null;
                }

                // Clean up response container
                this.commandPaletteResponse.style.display = 'none';
                this.commandPaletteResponseContent.textContent = '';
                this.commandPaletteResults.style.display = '';

                // Re-enable input
                this.commandPaletteInput.disabled = false;
            }

            setCommandPaletteMode(mode) {
                this.commandPaletteMode = mode;

                // Cancel any active streaming and clear response when switching modes
                if (this.activeCommandPaletteRequest) {
                    window.electronAPI.cancelChat(this.activeCommandPaletteRequest);
                    this.activeCommandPaletteRequest = null;
                }
                this.commandPaletteResponse.style.display = 'none';
                this.commandPaletteResponseContent.textContent = '';
                this.commandPaletteResults.style.display = '';
                this.commandPaletteInput.disabled = false;

                if (mode === 'search') {
                    this.commandPaletteModeSearch.classList.add('active');
                    this.commandPaletteModeAsk.classList.remove('active');
                    if (this.commandPalette) {
                        this.commandPalette.classList.remove('command-palette--ask-mode');
                    }
                    this.commandPaletteInput.placeholder = 'Search or Enter URL...';
                } else {
                    this.commandPaletteModeSearch.classList.remove('active');
                    this.commandPaletteModeAsk.classList.add('active');
                    if (this.commandPalette) {
                        this.commandPalette.classList.add('command-palette--ask-mode');
                    }
                    this.commandPaletteInput.placeholder = 'Ask a question...';
                }

                this.adjustCommandPaletteInputHeight();

                this.updateCommandPaletteResults();
                this.commandPaletteInput.focus();
            }

            adjustCommandPaletteInputHeight() {
                if (!this.commandPaletteInput) {
                    return;
                }
                
                if (this.commandPaletteMode === 'ask') {
                    this.commandPaletteInput.style.height = 'auto';
                    const computed = window.getComputedStyle(this.commandPaletteInput);
                    const minHeight = parseFloat(computed.minHeight) || 0;
                    const targetHeight = Math.max(this.commandPaletteInput.scrollHeight, minHeight);
                    this.commandPaletteInput.style.height = `${targetHeight}px`;
                } else {
                    this.commandPaletteInput.style.height = '';
                }
            }

            // Helper function to get favicon URL for a given URL
            getFaviconUrl(url, existingFavicon = '') {
                // If we already have a favicon, use it
                if (existingFavicon && existingFavicon.trim()) {
                    return existingFavicon;
                }
                
                // Extract domain from URL
                try {
                    let domain;
                    if (url.startsWith('http://') || url.startsWith('https://')) {
                        const urlObj = new URL(url);
                        domain = urlObj.hostname;
                    } else if (url.includes('://')) {
                        // Handle other protocols
                        return '';
                    } else {
                        // Assume https for relative URLs and extract domain
                        const parts = url.split('/')[0];
                        domain = parts.split('?')[0].split(':')[0]; // Remove query params and port
                    }
                    
                    if (!domain) {
                        return '';
                    }
                    
                    // Use Google's favicon service - use domain parameter for better compatibility
                    return `https://www.google.com/s2/favicons?domain=${encodeURIComponent(domain)}&sz=32`;
                } catch (err) {
                    // If URL parsing fails, try to extract domain manually
                    try {
                        const match = url.match(/(?:https?:\/\/)?(?:www\.)?([^\/\?]+)/);
                        if (match && match[1]) {
                            return `https://www.google.com/s2/favicons?domain=${encodeURIComponent(match[1])}&sz=32`;
                        }
                    } catch (e) {}
                    return '';
                }
            }

            updateCommandPaletteResults() {
                const query = this.commandPaletteInput.value.trim().toLowerCase();
                
                if (this.commandPaletteMode === 'ask') {
                    this.currentResults = [];
                    this.selectedResultIndex = -1;
                    this.hideAutocomplete();
                    if (this.commandPaletteResults) {
                        this.commandPaletteResults.innerHTML = '';
                    }
                    return;
                }
                
                const results = [];

                // Add open tabs
                this.tabs.forEach(tab => {
                    const friendlyTitle = this.getFriendlyTabTitle(tab);
                    const normalizedTitle = friendlyTitle.toLowerCase();
                    const normalizedUrl = (tab.url || '').toLowerCase();
                    const matchesQuery = !query || normalizedTitle.includes(query) || normalizedUrl.includes(query);
                    if (tab.id !== this.activeTabId && matchesQuery) {
                        const favicon = tab.railFavicon ? tab.railFavicon.src : '';
                        const friendlyUrl = tab.url && tab.url.includes('newtab.html')
                            ? friendlyTitle
                            : tab.url;
                        results.push({
                            type: 'tab',
                            title: friendlyTitle,
                            url: friendlyUrl,
                            favicon: this.getFaviconUrl(tab.url, favicon),
                            action: 'Switch to Tab',
                            data: tab
                        });
                    }
                });
                
                // Add history suggestions (limit to 5)
                if (this.history && this.history.length > 0) {
                    const historyMatches = this.history
                        .filter(entry => {
                            if (!query) return true;
                            const titleMatch = entry.title && entry.title.toLowerCase().includes(query);
                            const urlMatch = entry.url && entry.url.toLowerCase().includes(query);
                            return titleMatch || urlMatch;
                        })
                        .slice(0, 5)
                        .map(entry => ({
                            type: 'history',
                            title: entry.title || entry.url,
                            url: entry.url,
                            favicon: this.getFaviconUrl(entry.url, entry.favicon || ''),
                            action: 'Open',
                            data: entry
                        }));
                    results.push(...historyMatches);
                }
                
                // Add search suggestions if there's a query
                if (query && query.length > 0) {
                    results.push({
                        type: 'search',
                        title: `Search "${this.commandPaletteInput.value.trim()}"`,
                        url: `google.com/search?q=${encodeURIComponent(this.commandPaletteInput.value.trim())}`,
                        favicon: 'https://www.google.com/favicon.ico',
                        action: 'Search',
                        data: null
                    });
                }
                
                // Store results for autocomplete
                this.currentResults = results;
                
                // Update autocomplete
                this.updateAutocomplete();
                
                // Show results
                this.renderCommandPaletteResults(results);
            }

            updateAutocomplete() {
                const inputValue = this.commandPaletteInput.value;
                this.autocompleteText = '';
                
                // Only show autocomplete if there's text and we're in search mode
                if (!inputValue || this.commandPaletteMode !== 'search') {
                    this.hideAutocomplete();
                    return;
                }
                
                // Helper function to strip protocol from URL
                const stripProtocol = (url) => {
                    return url.replace(/^https?:\/\//, '').replace(/^www\./, '');
                };
                
                // Find the best match from history (prioritize URL matches that start with the input)
                const inputLower = inputValue.toLowerCase();
                let bestMatch = null;
                let matchedUrl = null;
                
                // Check history for URL matches
                if (this.history && this.history.length > 0) {
                    // Sort history by timestamp (most recent first)
                    const sortedHistory = [...this.history].sort((a, b) => (b.timestamp || 0) - (a.timestamp || 0));
                    
                    for (const entry of sortedHistory) {
                        if (!entry.url) continue;
                        
                        const url = entry.url.toLowerCase();
                        const urlStripped = stripProtocol(url);
                        
                        // Check if URL starts with input (with or without protocol)
                        if (url.startsWith(inputLower) || urlStripped.startsWith(inputLower)) {
                            matchedUrl = entry.url;
                            // Use the stripped version if that's what matched
                            bestMatch = urlStripped.startsWith(inputLower) ? stripProtocol(entry.url) : entry.url;
                            break;
                        }
                    }
                }
                
                // Check tabs for URL matches if no history match
                if (!bestMatch) {
                    for (const tab of this.tabs) {
                        if (!tab.url) continue;
                        
                        const url = tab.url.toLowerCase();
                        const urlStripped = stripProtocol(url);
                        
                        if (url.startsWith(inputLower) || urlStripped.startsWith(inputLower)) {
                            matchedUrl = tab.url;
                            bestMatch = urlStripped.startsWith(inputLower) ? stripProtocol(tab.url) : tab.url;
                            break;
                        }
                    }
                }
                
                if (bestMatch && bestMatch !== inputValue) {
                    this.autocompleteText = bestMatch;
                    this.showAutocomplete(inputValue, bestMatch);
                } else {
                    this.hideAutocomplete();
                }
            }

            showAutocomplete(inputValue, fullText) {
                // Show the full text in the autocomplete div
                // Create invisible prefix to align the completion
                const autocompletePortion = fullText.substring(inputValue.length);
                
                // Create the display with invisible prefix to align properly
                const invisiblePrefix = inputValue;
                this.commandPaletteAutocomplete.innerHTML = `<span style="opacity: 0;">${this.escapeHtml(invisiblePrefix)}</span>${this.escapeHtml(autocompletePortion)}`;
                this.commandPaletteAutocomplete.style.display = 'block';
            }

            hideAutocomplete() {
                this.commandPaletteAutocomplete.innerHTML = '';
                this.commandPaletteAutocomplete.style.display = 'none';
                this.autocompleteText = '';
            }

            renderCommandPaletteResults(results) {
                this.commandPaletteResults.innerHTML = '';
                
                if (results.length === 0 && this.commandPaletteInput.value.trim()) {
                    // Show "search web" option
                    const item = document.createElement('div');
                    item.className = 'command-palette-result-item';
                    
                    const faviconImg = document.createElement('img');
                    faviconImg.className = 'command-palette-result-favicon';
                    faviconImg.src = this.getFaviconUrl('https://www.google.com');
                    faviconImg.alt = '';
                    item.appendChild(faviconImg);
                    
                    const content = document.createElement('div');
                    content.className = 'command-palette-result-content';
                    const title = document.createElement('div');
                    title.className = 'command-palette-result-title';
                    title.textContent = 'Search the web';
                    const url = document.createElement('div');
                    url.className = 'command-palette-result-url';
                    url.textContent = 'Press Enter to search';
                    content.appendChild(title);
                    content.appendChild(url);
                    item.appendChild(content);
                    
                    item.addEventListener('click', () => this.executeCommandPaletteAction());
                    this.commandPaletteResults.appendChild(item);
                } else {
                    results.forEach((result, index) => {
                        const item = document.createElement('div');
                        item.className = 'command-palette-result-item';
                        if (index === this.selectedResultIndex) {
                            item.classList.add('selected');
                        }
                        
                        // Always try to show favicon (getFaviconUrl provides a fallback)
                        const faviconUrl = result.favicon || this.getFaviconUrl(result.url);
                        const resultUrl = result.url; // Store for closure
                        if (faviconUrl) {
                            const faviconImg = document.createElement('img');
                            faviconImg.className = 'command-palette-result-favicon';
                            faviconImg.src = faviconUrl;
                            faviconImg.alt = '';
                            faviconImg.onerror = function() {
                                // If favicon fails to load, try direct domain favicon
                                try {
                                    const urlObj = new URL(resultUrl);
                                    const domain = urlObj.hostname;
                                    const directFavicon = `https://${domain}/favicon.ico`;
                                    if (domain && this.src !== directFavicon) {
                                        this.src = directFavicon;
                                    } else {
                                        this.style.display = 'none';
                                    }
                                } catch (e) {
                                    this.style.display = 'none';
                                }
                            };
                            item.appendChild(faviconImg);
                        } else {
                            const faviconDiv = document.createElement('div');
                            faviconDiv.className = 'command-palette-result-favicon';
                            item.appendChild(faviconDiv);
                        }
                        
                        const content = document.createElement('div');
                        content.className = 'command-palette-result-content';
                        const title = document.createElement('div');
                        title.className = 'command-palette-result-title';
                        title.textContent = result.title;
                        const url = document.createElement('div');
                        url.className = 'command-palette-result-url';
                        url.textContent = result.url;
                        content.appendChild(title);
                        content.appendChild(url);
                        item.appendChild(content);
                        
                        const action = document.createElement('div');
                        action.className = 'command-palette-result-action';
                        action.textContent = `${result.action} →`;
                        item.appendChild(action);
                        
                        item.addEventListener('click', async () => {
                            if (result.type === 'tab') {
                                this.switchToTab(result.data.id);
                                this.hideCommandPalette();
                            } else if (result.type === 'history') {
                                this.hideCommandPalette();
                                await this.createTab(result.url);
                            } else if (result.type === 'search') {
                                this.executeCommandPaletteAction();
                            }
                        });
                        
                        this.commandPaletteResults.appendChild(item);
                    });
                }
            }

            selectNextResult() {
                const items = this.commandPaletteResults.querySelectorAll('.command-palette-result-item');
                if (items.length === 0) return;
                
                this.isNavigatingResults = true;
                this.selectedResultIndex = (this.selectedResultIndex + 1) % items.length;
                items.forEach((item, index) => {
                    item.classList.toggle('selected', index === this.selectedResultIndex);
                });
                
                // Update input with selected result
                this.updateInputWithSelectedResult();
                
                // Reset flag after a brief delay
                setTimeout(() => {
                    this.isNavigatingResults = false;
                }, 0);
            }

            selectPreviousResult() {
                const items = this.commandPaletteResults.querySelectorAll('.command-palette-result-item');
                if (items.length === 0) return;
                
                this.isNavigatingResults = true;
                this.selectedResultIndex = this.selectedResultIndex <= 0 
                    ? items.length - 1 
                    : this.selectedResultIndex - 1;
                items.forEach((item, index) => {
                    item.classList.toggle('selected', index === this.selectedResultIndex);
                });
                
                // Update input with selected result
                this.updateInputWithSelectedResult();
                
                // Reset flag after a brief delay
                setTimeout(() => {
                    this.isNavigatingResults = false;
                }, 0);
            }

            updateInputWithSelectedResult() {
                if (this.selectedResultIndex >= 0 && this.currentResults.length > 0) {
                    const selectedResult = this.currentResults[this.selectedResultIndex];
                    // Show appropriate value in the input field for visual feedback
                    if (selectedResult.type === 'search') {
                        // For search, extract the query from the title
                        const searchMatch = selectedResult.title.match(/Search "(.*)"/);
                        this.commandPaletteInput.value = searchMatch ? searchMatch[1] : selectedResult.title;
                    } else {
                        // For tabs and history, show the URL
                        this.commandPaletteInput.value = selectedResult.url;
                    }
                }
            }

            async executeSelectedResult(result) {
                this.hideCommandPalette();
                
                if (result.type === 'tab') {
                    this.switchToTab(result.data.id);
                } else if (result.type === 'history') {
                    await this.createTab(result.url);
                } else if (result.type === 'search') {
                    const value = this.commandPaletteInput.value.trim();
                    let targetUrl = value;
                    if (!/^https?:\/\//i.test(value)) {
                        targetUrl = value.includes('.') && !value.includes(' ')
                            ? 'https://' + value
                            : 'https://www.google.com/search?q=' + encodeURIComponent(value);
                    }
                    await this.createTab(targetUrl);
                }
            }

            async executeCommandPaletteAction() {
                const value = this.commandPaletteInput.value.trim();
                
                if (this.commandPaletteMode === 'search') {
                    // Search mode: create new tab with search or URL
                    if (!value) {
                        this.hideCommandPalette();
                        return;
                    }
                    
                    let targetUrl = value;
                    if (!/^https?:\/\//i.test(value)) {
                        targetUrl = value.includes('.') && !value.includes(' ')
                            ? 'https://' + value
                            : 'https://www.google.com/search?q=' + encodeURIComponent(value);
                    }
                    
                    this.hideCommandPalette();
                    await this.createTab(targetUrl);
                } else {
                    // Ask mode: open dedicated AI page instead of inline overlay
                    if (!value) {
                        this.hideCommandPalette();
                        return;
                    }

                    const askUrl = `newtab.html?mode=ask&query=${encodeURIComponent(value)}`;
                    this.hideCommandPalette();
                    await this.createTab(askUrl);
                }
            }

            async createInitialTab() {
                console.log('createInitialTab called');
                try {
                    // Try to restore saved tabs
                    const savedTabsData = await window.electronAPI.loadTabs();
                    if (savedTabsData && savedTabsData.tabs && savedTabsData.tabs.length > 0) {
                        console.log('Restoring saved tabs:', savedTabsData.tabs.length);
                        // Restore each saved tab
                        for (const savedTab of savedTabsData.tabs) {
                            const restoredState = {
                                isMuted: savedTab.isMuted || false,
                                isPinned: savedTab.isPinned || false,
                                pinnedHomeUrl: savedTab.pinnedHomeUrl || null
                            };
                            await this.createTab(savedTab.url, savedTab.id, savedTab.title, restoredState);
                        }
                        // Switch to the previously active tab if it still exists
                        if (savedTabsData.activeTabId) {
                            const restoredTab = this.tabs.find(t => t.id === savedTabsData.activeTabId);
                            if (restoredTab) {
                                await this.switchToTab(savedTabsData.activeTabId);
                            } else if (this.tabs.length > 0) {
                                // If saved active tab doesn't exist, use first tab
                                await this.switchToTab(this.tabs[0].id);
                            }
                        } else if (this.tabs.length > 0) {
                            await this.switchToTab(this.tabs[0].id);
                        }
                    } else {
                        // No saved tabs, create default tab
                        await this.createTab('https://www.google.com');
                    }
                } catch (error) {
                    console.error('Error restoring tabs:', error);
                    // Fallback to creating default tab
                    await this.createTab('https://www.google.com');
                }
            }

            switchToTab(tabId) {
                // Hide all webviews and deactivate tabs
                this.tabs.forEach(tab => {
                    tab.webview.style.display = 'none';
                    tab.tabElement.classList.remove('active');
                    tab.tabElement.setAttribute('aria-selected', 'false');
                    if (tab.railElement) {
                        tab.railElement.classList.remove('active');
                        tab.railElement.setAttribute('aria-selected', 'false');
                    }
                });

                // Show selected webview and activate tab
                const tab = this.tabs.find(t => t.id === tabId);
                if (tab) {
                    tab.webview.style.display = 'flex';
                    tab.tabElement.classList.add('active');
                    tab.tabElement.setAttribute('aria-selected', 'true');
                    if (tab.railElement) {
                        tab.railElement.classList.add('active');
                        tab.railElement.setAttribute('aria-selected', 'true');
                    }
                    this.activeTabId = tabId;
                    this.urlBar.value = this.getDisplayUrl(tab.url);
                    this.updateNavBarVisibility(tab.url);
                    this.updateActionButtonsVisibility(tab.url);

                    // Restore chat sidebar state for this tab
                    if (tab.chatSidebarOpen) {
                        this.showChatSidebar();
                    } else {
                        this.hideChatSidebar();
                    }
                    
                    this.updateChatContextUI(tab);
                    
                    // Save tabs after switching (debounced)
                    this.saveTabsDebounced();
                    
                    // Focus management
                    if (!this.urlBarContainer || this.urlBarContainer.style.display !== 'none') {
                        this.urlBar.focus();
                    } else if (tab.webview) {
                        tab.webview.focus();
                    }
                }
            }

            closeTab(tabId) {
                const tabIndex = this.tabs.findIndex(t => t.id === tabId);
                if (tabIndex === -1) return;

                const tab = this.tabs[tabIndex];
                if (tab.isPinned) {
                    this.resetPinnedTabToHome(tab);
                    if (this.activeTabId === tabId) {
                        const nextTab = this.findNextTabToActivate(tabId);
                        if (nextTab) {
                            this.switchToTab(nextTab.id);
                        }
                    }
                    this.showToast('Pinned tabs stay open. Unpin to close.');
                    return;
                }
                
                // Cancel any active chat requests for this tab's webview
                if (tab.webview && tab.webview.getWebContents) {
                    try {
                        const webContents = tab.webview.getWebContents();
                        if (webContents) {
                            // Cancel all active requests for this webContents
                            // The main process will handle this via the destroyed event,
                            // but we can also try to send a cancel message if the webview is still alive
                            const webContentsId = webContents.id;
                            // Note: The webContents destroyed event in main process will handle cleanup
                        }
                    } catch (e) {
                        // WebContents might already be destroyed, that's fine
                    }
                }
                
                this.rememberClosedTab(tab);
                
                // Remove from DOM
                tab.tabElement.remove();
                tab.webview.remove();
                if (tab.railElement) tab.railElement.remove();
                
                // Remove from tabs array
                this.tabs.splice(tabIndex, 1);

                // If this was the active tab, switch to another
                if (this.activeTabId === tabId) {
                    if (this.tabs.length > 0) {
                        const newActiveTab = this.tabs[Math.max(0, tabIndex - 1)];
                        this.switchToTab(newActiveTab.id);
                    } else {
                        // No tabs left, create a new one
                        this.createTab();
                    }
                }
                
                // Save tabs after closing (debounced)
                this.saveTabsDebounced();
            }

            closeActiveTab() {
                if (this.activeTabId) {
                    this.closeTab(this.activeTabId);
                }
            }

            resetPinnedTabToHome(tab) {
                if (!tab || !tab.isPinned || !tab.pinnedHomeUrl) {
                    return;
                }

                const targetUrl = tab.pinnedHomeUrl;
                let currentUrl = null;

                try {
                    if (tab.webview && typeof tab.webview.getURL === 'function') {
                        currentUrl = tab.webview.getURL();
                    }
                } catch (error) {
                    console.warn('Unable to read current URL for pinned tab:', error);
                }

                if (tab.webview) {
                    const shouldLoad = currentUrl !== targetUrl || !currentUrl;
                    if (shouldLoad) {
                        if (typeof tab.webview.loadURL === 'function') {
                            tab.webview.loadURL(targetUrl);
                        } else {
                            tab.webview.setAttribute('src', targetUrl);
                        }
                    }
                }

                tab.url = targetUrl;

                if (this.activeTabId === tab.id) {
                    this.urlBar.value = this.getDisplayUrl(targetUrl);
                    this.updateNavBarVisibility(targetUrl);
                    this.updateActionButtonsVisibility(targetUrl);
                }

                this.saveTabsDebounced();
            }

            getEffectiveTabUrl(tab) {
                if (!tab) return null;

                try {
                    if (tab.webview && typeof tab.webview.getURL === 'function') {
                        const currentUrl = tab.webview.getURL();
                        if (currentUrl) {
                            return currentUrl;
                        }
                    }
                } catch (error) {
                    console.warn('Unable to read current URL for tab:', error);
                }

                return tab.url || null;
            }

            rememberClosedTab(tab) {
                if (!tab) return;

                let url = tab.url;
                try {
                    if (tab.webview && typeof tab.webview.getURL === 'function') {
                        const currentUrl = tab.webview.getURL();
                        if (currentUrl) {
                            url = currentUrl;
                        }
                    }
                } catch (error) {
                    console.warn('Unable to read current URL for closed tab:', error);
                }

                let title = tab.title || 'New Tab';
                try {
                    if (tab.webview && typeof tab.webview.getTitle === 'function') {
                        const currentTitle = tab.webview.getTitle();
                        if (currentTitle) {
                            title = currentTitle;
                        }
                    }
                } catch (error) {
                    console.warn('Unable to read current title for closed tab:', error);
                }

                const snapshot = {
                    url: url || 'https://www.google.com',
                    title,
                    isMuted: !!tab.isMuted,
                    isPinned: !!tab.isPinned
                };

                this.closedTabs.push(snapshot);
                if (this.closedTabs.length > this.maxClosedTabHistory) {
                    this.closedTabs.shift();
                }
            }

            async reopenLastClosedTab() {
                if (!this.closedTabs.length) {
                    this.showToast('No recently closed tabs');
                    return;
                }

                const lastClosed = this.closedTabs.pop();
                const restoredState = {
                    isMuted: !!lastClosed.isMuted,
                    isPinned: !!lastClosed.isPinned
                };

                try {
                    await this.createTab(
                        lastClosed.url || 'https://www.google.com',
                        null,
                        lastClosed.title || 'New Tab',
                        restoredState
                    );
                    this.showToast('Reopened closed tab');
                } catch (error) {
                    console.error('Error reopening closed tab:', error);
                    this.showToast('Unable to reopen tab');
                }
            }

            findNextTabToActivate(currentTabId) {
                if (this.tabs.length <= 1) {
                    return null;
                }

                const currentIndex = this.tabs.findIndex(t => t.id === currentTabId);
                const orderedTabs = currentIndex === -1
                    ? [...this.tabs]
                    : [
                        ...this.tabs.slice(currentIndex + 1),
                        ...this.tabs.slice(0, currentIndex)
                    ];

                return orderedTabs.find(t => !t.isPinned) || orderedTabs.find(t => t.id !== currentTabId) || null;
            }

            handleTabMuted(tabId) {
                const tab = this.tabs.find(t => t.id === tabId);
                if (!tab) return;

                // Toggle mute state
                tab.isMuted = !tab.isMuted;

                // Update webview audio state
                if (tab.webview) {
                    tab.webview.setAudioMuted(tab.isMuted);
                }

                // Update visual indicator
                this.updateTabVisuals(tab);

                // Save tabs state (debounced)
                this.saveTabsDebounced();

                // Show toast notification
                const message = tab.isMuted ? 'Tab muted' : 'Tab unmuted';
                this.showToast(message);
            }

            handleDuplicateTab(tabId) {
                const tab = this.tabs.find(t => t.id === tabId);
                if (!tab) return;

                // Create new tab with same URL
                this.createTab(tab.url);

                // Show toast notification
                this.showToast('Tab duplicated');
            }

            handlePinTab(tabId) {
                const tab = this.tabs.find(t => t.id === tabId);
                if (!tab) return;

                // Toggle pin state
                tab.isPinned = !tab.isPinned;
                if (tab.isPinned) {
                    tab.pinnedHomeUrl = this.getEffectiveTabUrl(tab);
                } else {
                    tab.pinnedHomeUrl = null;
                }

                // Update visual indicator
                this.updateTabVisuals(tab);

                // Reorder tabs: pinned tabs should be at the top
                this.reorderTabs();

                // Save tabs state (debounced)
                this.saveTabsDebounced();

                // Show toast notification
                const message = tab.isPinned ? 'Tab pinned' : 'Tab unpinned';
                this.showToast(message);
            }

            updateTabVisuals(tab) {
                if (tab.railElement) {
                    // Update muted state
                    if (tab.isMuted) {
                        tab.railElement.classList.add('muted');

                        // Add muted icon if not already present
                        if (!tab.railElement.querySelector('.muted-icon')) {
                            const mutedIcon = document.createElement('span');
                            mutedIcon.className = 'muted-icon';
                            mutedIcon.innerHTML = '🔇';
                            mutedIcon.setAttribute('title', 'Tab is muted');
                            tab.railElement.insertBefore(mutedIcon, tab.railElement.querySelector('.rail-close-btn'));
                        }
                    } else {
                        tab.railElement.classList.remove('muted');
                        const mutedIcon = tab.railElement.querySelector('.muted-icon');
                        if (mutedIcon) mutedIcon.remove();
                    }

                    tab.railElement.classList.toggle('pinned', tab.isPinned);
                }

                if (tab.tabElement) {
                    tab.tabElement.classList.toggle('pinned', tab.isPinned);
                }

                const updateCloseButton = (button) => {
                    if (!button) return;
                    if (tab.isPinned) {
                        button.disabled = true;
                        button.setAttribute('disabled', '');
                        button.setAttribute('aria-hidden', 'true');
                        button.setAttribute('tabindex', '-1');
                    } else {
                        button.disabled = false;
                        button.removeAttribute('disabled');
                        button.removeAttribute('aria-hidden');
                        button.removeAttribute('tabindex');
                    }
                };

                updateCloseButton(tab.tabCloseBtn);
                updateCloseButton(tab.railCloseBtn);
            }

            reorderTabs() {
                // Separate pinned and unpinned tabs
                const pinnedTabs = this.tabs.filter(t => t.isPinned);
                const unpinnedTabs = this.tabs.filter(t => !t.isPinned);

                // Clear the rail container
                this.tabRailTabs.innerHTML = '';

                // Add pinned tabs first, then unpinned tabs
                [...pinnedTabs, ...unpinnedTabs].forEach(tab => {
                    if (tab.railElement) {
                        this.tabRailTabs.appendChild(tab.railElement);
                    }
                });

                // Update the tabs array to reflect the new order
                this.tabs = [...pinnedTabs, ...unpinnedTabs];
            }

            async navigateToUrl() {
                const url = this.urlBar.value.trim();
                if (!url) return;

                const result = await window.electronAPI.navigateTo(url);
                if (result.success && this.activeTabId) {
                    const tab = this.tabs.find(t => t.id === this.activeTabId);
                    if (tab) {
                        tab.webview.loadURL(result.url);
                        tab.url = result.url;
                        this.updateActionButtonsVisibility(result.url);
                        // Save tabs after navigation (debounced)
                        this.saveTabsDebounced();
                    }
                }
            }

            navigateBack() {
                if (this.activeTabId) {
                    const tab = this.tabs.find(t => t.id === this.activeTabId);
                    if (tab && tab.webview.canGoBack()) {
                        tab.webview.goBack();
                    }
                }
            }

            navigateForward() {
                if (this.activeTabId) {
                    const tab = this.tabs.find(t => t.id === this.activeTabId);
                    if (tab && tab.webview.canGoForward()) {
                        tab.webview.goForward();
                    }
                }
            }

            refreshPage() {
                if (this.activeTabId) {
                    const tab = this.tabs.find(t => t.id === this.activeTabId);
                    if (tab) {
                        tab.webview.reload();
                    }
                }
            }

            async handleChatSend() {
                if (!this.chatInput) return;
                const message = this.chatInput.value.trim();
                if (!message) return;
                this.chatInput.value = '';
            
                const tabId = this.activeTabId;
                const session = this.chatSessions.get(tabId) || [];
            
                // Add user message to session and UI
                session.push({ role: 'user', content: message });
                this.renderChatHistory(); // Re-render to show user message
            
                // Get context from all referenced tabs
                const activeTab = this.tabs.find(t => t.id === this.activeTabId);
                const contexts = [];
                
                if (activeTab) {
                    for (const tabId of activeTab.referencedTabs) {
                        const referencedTab = this.tabs.find(t => t.id === tabId);
                        if (referencedTab) {
                            try {
                                const context = await this.getPageContext(referencedTab);
                                if (context) contexts.push(context);
                            } catch (err) {
                                console.error(`Failed to get page context for referenced tab ${tabId}:`, err);
                            }
                        }
                    }
                }

                // Don't add assistant message to session yet - we'll add it when we start receiving tokens
                // This prevents showing an empty assistant message alongside the status indicator
                let assistantMessage = null;
                let assistantMessageIndex = -1;
            
                // Re-render to show user message
                this.renderChatHistory();
                this.chatHistory.scrollTop = this.chatHistory.scrollHeight;
            
                // Generate unique request ID and send to main process
                const reqId = Date.now().toString();
                // Enable web search for ask section (sidebar chat)
                const webSearchOptions = {
                    enableWebSearch: true,
                    model: 'gpt-5',
                    externalWebAccess: true
                };
                
                // Show status indicator in chat history - start with "Searching the web..." since web search is enabled
                this.showStatusIndicator('Searching the web...');
                
                window.electronAPI.sendChat(reqId, session, contexts, webSearchOptions); // Send all messages (no assistant placeholder yet)
            
                const streamHandler = (data) => {
                    if (data.id !== reqId) return;
            
                    if (data.token) {
                        // Add assistant message to session when we receive first token
                        if (!assistantMessage) {
                            assistantMessage = { role: 'assistant', content: '' };
                            session.push(assistantMessage);
                            assistantMessageIndex = session.length - 1;
                            // Hide status indicator and render the actual assistant message
                            this.hideStatusIndicator();
                            this.renderChatHistory();
                        }
                        
                        // Always update the session state in the background
                        assistantMessage.content += data.token;
            
                        // Only update the DOM if the message's tab is active
                        if (this.activeTabId === tabId) {
                            const msgContainer = document.getElementById(`asst-msg-${tabId}-${assistantMessageIndex}`);
                            if (msgContainer) {
                                const contentEl = msgContainer.querySelector('.chat-content');
                                // Update with raw text during stream for performance
                                contentEl.classList.remove('markdown-rendered');
                                contentEl.textContent = assistantMessage.content;
                                this.chatHistory.scrollTop = this.chatHistory.scrollHeight;
                            }
                        }
                    } else if (data.metadata) {
                        // Store metadata (sources, citations) in the assistant message
                        if (!assistantMessage.metadata) {
                            assistantMessage.metadata = {};
                        }
                        if (data.metadata.sources) {
                            assistantMessage.metadata.sources = data.metadata.sources;
                        }
                        if (data.metadata.citations) {
                            assistantMessage.metadata.citations = data.metadata.citations;
                        }
                    } else if (data.done) {
                        // Store final metadata if present
                        if (data.sources) {
                            if (!assistantMessage.metadata) assistantMessage.metadata = {};
                            assistantMessage.metadata.sources = data.sources;
                        }
                        if (data.citations) {
                            if (!assistantMessage.metadata) assistantMessage.metadata = {};
                            assistantMessage.metadata.citations = data.citations;
                        }
                        // Final state is already in assistantMessage.content
                        // Re-render one last time with markdown if the tab is active
                        if (this.activeTabId === tabId) {
                            const msgContainer = document.getElementById(`asst-msg-${tabId}-${assistantMessageIndex}`);
                            if (msgContainer) {
                                const contentEl = msgContainer.querySelector('.chat-content');
                                contentEl.innerHTML = this.marked.parse(assistantMessage.content);
                                contentEl.classList.add('markdown-rendered');
                                // Add citations if available
                                this.renderCitations(msgContainer, assistantMessage.metadata);
                            }
                        }
                        // Hide status indicator when done
                        this.hideStatusIndicator();
                        
                        // Save chat session after completion
                        this.saveChatSession(tabId);
                        window.electronAPI.removeListener('chat-stream', streamHandler);
                    } else if (data.error) {
                        assistantMessage.content = `Error: ${data.error}`;
                        if (this.activeTabId === tabId) {
                            this.renderChatHistory(); // Re-render to show the error
                        }
                        
                        // Hide status indicator on error
                        this.hideStatusIndicator();
                        
                        window.electronAPI.removeListener('chat-stream', streamHandler);
                    }
                };
            
                window.electronAPI.onChatStream(streamHandler);
            }

            async handleSummarizePage() {
                const tabId = this.activeTabId;
                const activeTab = this.tabs.find(t => t.id === tabId);
                if (!activeTab) {
                    return;
                }

                this.showChatSidebar();

                const session = this.chatSessions.get(tabId) || [];
                session.push({ role: 'user', content: 'Summarize this page.' });

                const assistantMessage = { role: 'assistant', content: '' };
                session.push(assistantMessage);
                const assistantMessageIndex = session.length - 1;

                this.renderChatHistory();
                this.chatHistory.scrollTop = this.chatHistory.scrollHeight;

                const contexts = [];
                try {
                    const context = await this.getPageContext(activeTab);
                    if (context) contexts.push(context);
                } catch (err) {
                    console.error('Failed to get page context for summarization:', err);
                }

                const reqId = Date.now().toString();
                window.electronAPI.sendChat(reqId, session.slice(0, -1), contexts);

                const streamHandler = (data) => {
                    if (data.id !== reqId) return;

                    if (data.token) {
                        assistantMessage.content += data.token;
                        if (this.activeTabId === tabId) {
                            const msgContainer = document.getElementById(`asst-msg-${tabId}-${assistantMessageIndex}`);
                            if (msgContainer) {
                                const contentEl = msgContainer.querySelector('.chat-content');
                                contentEl.classList.remove('markdown-rendered');
                                contentEl.textContent = assistantMessage.content;
                                this.chatHistory.scrollTop = this.chatHistory.scrollHeight;
                            }
                        }
                    } else if (data.done) {
                        if (this.activeTabId === tabId) {
                            const msgContainer = document.getElementById(`asst-msg-${tabId}-${assistantMessageIndex}`);
                            if (msgContainer) {
                                const contentEl = msgContainer.querySelector('.chat-content');
                                contentEl.innerHTML = this.marked.parse(assistantMessage.content);
                                contentEl.classList.add('markdown-rendered');
                            }
                        }
                        // Save chat session after completion
                        this.saveChatSession(tabId);
                        window.electronAPI.removeListener('chat-stream', streamHandler);
                    } else if (data.error) {
                        assistantMessage.content = `Error: ${data.error}`;
                        if (this.activeTabId === tabId) {
                            this.renderChatHistory();
                        }
                        window.electronAPI.removeListener('chat-stream', streamHandler);
                    }
                };

                window.electronAPI.onChatStream(streamHandler);
            }

            async getPageContext(tab) {
                if (!tab || !tab.webview || tab.isLoading || tab.webview.isCrashed()) {
                    return null;
                }
                const webview = tab.webview;

                try {
                    const pageUrl = webview.getURL();
                    if (!pageUrl.startsWith('http')) {
                        return null;
                    }
                    const pageTitle = webview.getTitle();
                    const pageContent = await webview.executeJavaScript('document.body.innerText');
                    return {
                        title: pageTitle,
                        url: pageUrl,
                        content: pageContent.substring(0, 4000) // Truncate for performance
                    };
                } catch (e) {
                    console.error(`Could not get page context: `, e);
                    return null;
                }
            }


            isActiveTabAiChatSurface() {
                const activeTab = this.tabs.find(tab => tab.id === this.activeTabId);
                if (!activeTab || !activeTab.url || !activeTab.url.includes('newtab.html')) {
                    return false;
                }
                return !!activeTab.isAiChatSurface;
            }

            canToggleChatSidebar() {
                if (!this.chatSidebar) {
                    return false;
                }
                const isOpen = this.chatSidebar.classList.contains('open');
                if (!isOpen && this.isActiveTabAiChatSurface()) {
                    return false;
                }
                return true;
            }

            toggleChatSidebar() {
                if (!this.chatSidebar) return;
                const isOpen = this.chatSidebar.classList.contains('open');
                
                if (isOpen) {
                    this.hideChatSidebar();
                } else {
                    this.showChatSidebar();
                }
            }

            showToast(message) {
                // Remove any existing toast
                const existingToast = document.querySelector('.toast-notification');
                if (existingToast) {
                    existingToast.remove();
                }

                // Create new toast
                const toast = document.createElement('div');
                toast.className = 'toast-notification';
                toast.textContent = message;
                document.body.appendChild(toast);

                // Show toast
                requestAnimationFrame(() => {
                    toast.classList.add('show');
                });

                // Hide after 2 seconds
                setTimeout(() => {
                    toast.classList.remove('show');
                    setTimeout(() => {
                        if (toast.parentNode) {
                            toast.remove();
                        }
                    }, 300); // Wait for fade out animation
                }, 2000);
            }

            showChatSidebar() {
                if (!this.chatSidebar) return;
                const currentTab = this.tabs.find(t => t.id === this.activeTabId);
                if (!currentTab) return;

                // Don't show if already open
                if (this.chatSidebar.classList.contains('open')) return;

                // Auto-add current page as context if not already added
                if (!currentTab.referencedTabs.has(currentTab.id)) {
                    currentTab.referencedTabs.add(currentTab.id);
                }
                
                this.chatSidebar.style.display = 'flex';
                this.chatSidebar.classList.add('open');
                this.updateContentAreaWidth();
                this.chatInput.focus();
                this.renderChatHistory();
                this.updateChatContextUI(currentTab);
                currentTab.chatSidebarOpen = true;
            }

            hideChatSidebar(clearHistory = false) {
                if (!this.chatSidebar) return;
                this.chatSidebar.classList.remove('open');
                this.updateContentAreaWidth();

                const currentTab = this.tabs.find(t => t.id === this.activeTabId);
                if (currentTab) {
                    currentTab.chatSidebarOpen = false;
                }
                if (clearHistory) {
                    this.chatHistory.innerHTML = '';
                }
                
                // Hide sidebar immediately
                this.chatSidebar.style.display = '';
            }

            updateChatContextUI(tab) {
                this.renderContextPills();
                const hasContext = tab && tab.referencedTabs.size > 0;
                this.chatInput.placeholder = hasContext ? 'Ask a question about the page(s)...' : 'Ask AI...';
            }

            dismissPageContext() {
                // This function is no longer needed as individual pills are dismissed.
            }

            renderChatHistory() {
                if (!this.chatHistory) return;
                this.chatHistory.innerHTML = '';
                const messages = this.chatSessions.get(this.activeTabId) || [];
                messages.forEach((msg, index) => {
                    const wrapper = document.createElement('div');
                    wrapper.className = `chat-msg ${msg.role === 'user' ? 'user-msg' : 'assistant-msg'}`;
                    // Add a unique ID to the assistant message wrapper for easy targeting
                    if (msg.role === 'assistant') {
                        wrapper.id = `asst-msg-${this.activeTabId}-${index}`;
                    }
                    const label = document.createElement('div');
                    label.className = 'chat-label';
                    label.textContent = msg.role === 'user' ? 'You' : 'AI';
                    const content = document.createElement('div');
                    content.className = 'chat-content';
                    if (msg.role === 'assistant') {
                        content.innerHTML = this.marked.parse(msg.content || '');
                        content.classList.add('markdown-rendered');
                    } else {
                        content.textContent = msg.content || '';
                    }
                    wrapper.appendChild(label);
                    wrapper.appendChild(content);
                    // Add citations if available
                    if (msg.role === 'assistant' && msg.metadata) {
                        this.renderCitations(wrapper, msg.metadata);
                    }
                    this.chatHistory.appendChild(wrapper);
                });
                this.chatHistory.scrollTop = this.chatHistory.scrollHeight;
            }

            renderCitations(msgContainer, metadata) {
                if (!metadata || !msgContainer) return;
                
                // Remove existing citations container if present
                const existingCitations = msgContainer.querySelector('.chat-citations');
                if (existingCitations) {
                    existingCitations.remove();
                }
                
                const citations = metadata.citations || [];
                const sources = metadata.sources || [];
                
                // Only render if we have citations or sources
                if (citations.length === 0 && sources.length === 0) return;
                
                const citationsContainer = document.createElement('div');
                citationsContainer.className = 'chat-citations';
                
                // Render citations (inline citations from the response)
                if (citations.length > 0) {
                    const citationsTitle = document.createElement('div');
                    citationsTitle.className = 'citations-title';
                    citationsTitle.textContent = 'Sources:';
                    citationsContainer.appendChild(citationsTitle);
                    
                    const citationsList = document.createElement('div');
                    citationsList.className = 'citations-list';
                    
                    // Use unique citations by URL
                    const uniqueCitations = new Map();
                    citations.forEach(citation => {
                        if (citation.url && !uniqueCitations.has(citation.url)) {
                            uniqueCitations.set(citation.url, citation);
                        }
                    });
                    
                    uniqueCitations.forEach(citation => {
                        const citationItem = document.createElement('a');
                        citationItem.className = 'citation-item';
                        citationItem.href = citation.url;
                        citationItem.target = '_blank';
                        citationItem.rel = 'noopener noreferrer';
                        citationItem.textContent = citation.title || citation.url;
                        citationItem.title = citation.url;
                        citationsList.appendChild(citationItem);
                    });
                    
                    citationsContainer.appendChild(citationsList);
                }
                
                // Render sources (all URLs consulted)
                if (sources.length > 0 && sources.length > (metadata.citations?.length || 0)) {
                    const sourcesTitle = document.createElement('div');
                    sourcesTitle.className = 'sources-title';
                    sourcesTitle.textContent = 'All sources consulted:';
                    citationsContainer.appendChild(sourcesTitle);
                    
                    const sourcesList = document.createElement('div');
                    sourcesList.className = 'sources-list';
                    
                    sources.forEach(source => {
                        if (typeof source === 'string') {
                            const sourceItem = document.createElement('a');
                            sourceItem.className = 'source-item';
                            sourceItem.href = source;
                            sourceItem.target = '_blank';
                            sourceItem.rel = 'noopener noreferrer';
                            sourceItem.textContent = source;
                            sourcesList.appendChild(sourceItem);
                        }
                    });
                    
                    citationsContainer.appendChild(sourcesList);
                }
                
                if (citationsContainer.children.length > 0) {
                    msgContainer.appendChild(citationsContainer);
                }
            }

            showStatusIndicator(text) {
                if (!this.chatHistory) return;
                // Remove existing status indicator if present
                this.hideStatusIndicator();
                // Create new status indicator
                const statusWrapper = document.createElement('div');
                statusWrapper.className = 'chat-msg assistant-msg';
                statusWrapper.id = 'chat-status-indicator-wrapper';
                const label = document.createElement('div');
                label.className = 'chat-label';
                label.textContent = 'AI';
                const statusContainer = document.createElement('div');
                statusContainer.className = 'chat-status-indicator';
                
                // Add search icon
                const iconSvg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                iconSvg.setAttribute('width', '16');
                iconSvg.setAttribute('height', '16');
                iconSvg.setAttribute('viewBox', '0 0 24 24');
                iconSvg.setAttribute('fill', 'none');
                iconSvg.setAttribute('stroke', 'currentColor');
                iconSvg.setAttribute('stroke-width', '2');
                iconSvg.setAttribute('stroke-linecap', 'round');
                iconSvg.setAttribute('stroke-linejoin', 'round');
                iconSvg.classList.add('chat-status-indicator-icon');
                const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                circle.setAttribute('cx', '11');
                circle.setAttribute('cy', '11');
                circle.setAttribute('r', '8');
                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                path.setAttribute('d', 'm21 21-4.35-4.35');
                iconSvg.appendChild(circle);
                iconSvg.appendChild(path);
                
                const statusText = document.createElement('span');
                statusText.className = 'status-text';
                statusText.textContent = text;
                statusContainer.appendChild(iconSvg);
                statusContainer.appendChild(statusText);
                statusWrapper.appendChild(label);
                statusWrapper.appendChild(statusContainer);
                this.chatHistory.appendChild(statusWrapper);
                this.chatHistory.scrollTop = this.chatHistory.scrollHeight;
            }

            updateStatusIndicator(text) {
                if (!this.chatHistory) return;
                const statusWrapper = document.getElementById('chat-status-indicator-wrapper');
                if (statusWrapper) {
                    const statusText = statusWrapper.querySelector('.status-text');
                    if (statusText) {
                        statusText.textContent = text;
                    }
                }
            }

            hideStatusIndicator() {
                if (!this.chatHistory) return;
                const statusWrapper = document.getElementById('chat-status-indicator-wrapper');
                if (statusWrapper) {
                    statusWrapper.remove();
                }
            }

            clearChat() {
                this.chatSessions.set(this.activeTabId, []);
                if (this.chatHistory) {
                    this.chatHistory.innerHTML = '';
                }
                // Hide status indicator when clearing chat
                this.hideStatusIndicator();
                // Also reset the context dismissal state
                const tab = this.tabs.find(t => t.id === this.activeTabId);
                if (tab) {
                    tab.referencedTabs.clear();
                    // Re-add current tab as context
                    tab.referencedTabs.add(tab.id);
                    this.updateChatContextUI(tab);
                }
                // Save empty session to clear stored chat
                this.saveChatSession(this.activeTabId);
            }

            handleChatInput() {
                const value = this.chatInput.value;
                const atIndex = value.lastIndexOf('@');

                if (atIndex > -1 && (atIndex === 0 || /\s/.test(value[atIndex - 1]))) {
                    const query = value.substring(atIndex + 1);
                    this.showTabSuggestions(query);
                } else {
                    this.hideTabSuggestions();
                }
            }

            handleSuggestionClick(e) {
                const item = e.target.closest('.suggestion-item');
                if (!item) return;

                const tabId = item.getAttribute('data-tab-id');
                const activeTab = this.tabs.find(t => t.id === this.activeTabId);

                if (tabId && activeTab) {
                    activeTab.referencedTabs.add(tabId);
                    this.updateChatContextUI(activeTab);

                    const atIndex = this.chatInput.value.lastIndexOf('@');
                    this.chatInput.value = this.chatInput.value.substring(0, atIndex);
                    this.hideTabSuggestions();
                    this.chatInput.focus();
                }
            }

            showTabSuggestions(query) {
                const activeTab = this.tabs.find(t => t.id === this.activeTabId);
                const filteredTabs = this.tabs.filter(tab =>
                    !activeTab.referencedTabs.has(tab.id) &&
                    (tab.title.toLowerCase().includes(query.toLowerCase()) ||
                     tab.url.toLowerCase().includes(query.toLowerCase()))
                );

                if (filteredTabs.length > 0) {
                    this.tabSuggestions.innerHTML = filteredTabs.map(tab => `
                        <div class="suggestion-item" data-tab-id="${tab.id}">
                            <div class="suggestion-title">${this.escapeHtml(tab.title)}</div>
                            <div class="suggestion-url">${this.escapeHtml(tab.url)}</div>
                        </div>
                    `).join('');
                    this.tabSuggestions.style.display = 'block';
                } else {
                    this.hideTabSuggestions();
                }
            }

            hideTabSuggestions() {
                this.tabSuggestions.style.display = 'none';
                this.tabSuggestions.innerHTML = '';
            }

            escapeHtml(str) {
                return str.replace(/[&<>"']/g, (match) => {
                    return {
                        '&': '&amp;',
                        '<': '&lt;',
                        '>': '&gt;',
                        '"': '&quot;',
                        "'": '&#39;'
                    }[match];
                });
            }

            handleSuggestionKeyboardNav(e) {
                // Future implementation for arrow key navigation
            }

            renderContextPills() {
                this.contextPillsContainer.innerHTML = '';
                const activeTab = this.tabs.find(t => t.id === this.activeTabId);
                if (!activeTab) return;

                for (const tabId of activeTab.referencedTabs) {
                    const tab = this.tabs.find(t => t.id === tabId);
                    if (tab) {
                        const friendlyTitle = this.getFriendlyTabTitle(tab);
                        const pill = document.createElement('div');
                        pill.className = 'context-pill';
                        pill.innerHTML = `
                            <span class="context-pill-title" title="${this.escapeHtml(friendlyTitle)}">${this.escapeHtml(friendlyTitle)}</span>
                            <button class="context-pill-remove" data-tab-id="${tab.id}">&times;</button>
                        `;
                        this.contextPillsContainer.appendChild(pill);
                    }
                }

                // Add event listeners to remove buttons
                this.contextPillsContainer.querySelectorAll('.context-pill-remove').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        const tabIdToRemove = e.currentTarget.getAttribute('data-tab-id');
                        activeTab.referencedTabs.delete(tabIdToRemove);
                        this.updateChatContextUI(activeTab);
                    });
                });
            }

            async openSavedChat(chatId) {
                if (!chatId) {
                    return;
                }
                try {
                    if (!window.electronAPI || typeof window.electronAPI.loadChats !== 'function') {
                        console.warn('electronAPI.loadChats is not available');
                        return;
                    }

                    const chats = await window.electronAPI.loadChats();
                    const chatEntry = chats ? chats[chatId] : null;
                    if (!chatEntry || !Array.isArray(chatEntry.session)) {
                        this.showToast('Chat not found');
                        return;
                    }

                    const restoredTitle = chatEntry.title || 'AI Chat Session';
                    const chatUrl = `newtab.html?mode=ask&chatId=${encodeURIComponent(chatEntry.id)}`;
                    const newTab = await this.createTab(chatUrl, null, restoredTitle);
                    if (!newTab || !newTab.webview) {
                        this.showToast('Unable to open chat');
                        return;
                    }

	                    const sessionClone = chatEntry.session.map((msg) => ({ ...msg }));
	                    this.chatSessions.set(newTab.id, sessionClone);

	                    const payload = {
	                        type: 'load-chat-session',
	                        chatId: chatEntry.id,
	                        title: chatEntry.title || restoredTitle,
	                        session: sessionClone
	                    };
                    // Send payload in case the newly opened tab can consume it directly (fallback for legacy flows)
                    try {
                        newTab.webview.send('guest-message', payload);
                    } catch (error) {
                        console.warn('Deferred chat payload delivery failed; relying on in-tab restoration.', error);
                    }
                } catch (error) {
                    console.error('Error opening saved chat:', error);
                    this.showToast('Unable to open chat');
                }
            }

            async showHistory() {
                // Create or switch to history tab
                const historyUrl = 'history.html';
                const existingTab = this.tabs.find(t => t.url && t.url.includes('history.html'));

                if (existingTab) {
                    this.switchToTab(existingTab.id);
                } else {
                    await this.createTab(historyUrl);
                }
            }

            async copyCurrentUrl() {
                try {
                    const activeTab = this.tabs.find(tab => tab.id === this.activeTabId);
                    if (!activeTab || !activeTab.webview) {
                        console.error('No active tab or webview found');
                        return;
                    }

                    const url = activeTab.webview.getURL();
                    if (url) {
                        await window.electronAPI.copyToClipboard(url);
                        this.showToast('URL copied to clipboard');
                    } else {
                        console.error('Failed to get URL from webview');
                    }
                } catch (error) {
                    console.error('Error copying URL:', error);
                }
            }

            async saveHistoryEntry(url, title, favicon) {
                try {
                    // Don't save history in incognito mode
                    if (this.isIncognito) {
                        return;
                    }
                    // Skip internal pages
                    if (url.includes('history.html') || url.includes('newtab.html')) {
                        return;
                    }
                    await window.electronAPI.addHistory(url, title, favicon);
                    // Reload history for command palette suggestions
                    await this.loadHistory();
                } catch (error) {
                    console.error('Error saving history:', error);
                }
            }

            async saveChatSession(tabId) {
                try {
                    // Don't save chat sessions in incognito mode
                    if (this.isIncognito) {
                        return;
                    }
                    const session = this.chatSessions.get(tabId);
                    if (session && session.length > 0) {
                        await window.electronAPI.saveChat(tabId, session);
                    }
                } catch (error) {
                    console.error('Error saving chat session:', error);
                }
            }
        }

        // Initialize the browser when the page loads
        document.addEventListener('DOMContentLoaded', () => {
            try {
                const browser = new BrowserManager();
                // Save tabs before window closes
                window.addEventListener('beforeunload', () => {
                    if (browser && !browser.isIncognito) {
                        // Clear debounce and save immediately
                        if (browser.saveTabsTimeout) {
                            clearTimeout(browser.saveTabsTimeout);
                        }
                        browser.saveTabs();
                    }
                });

                // Setup quit dialog
                const quitDialog = document.getElementById('quitDialog');
                const quitCancelBtn = document.getElementById('quitCancelBtn');
                const quitConfirmBtn = document.getElementById('quitConfirmBtn');

                function showQuitDialog() {
                    if (quitDialog) {
                        quitDialog.style.display = 'flex';
                        // Focus the cancel button for accessibility
                        if (quitCancelBtn) {
                            quitCancelBtn.focus();
                        }
                    }
                }

                function hideQuitDialog() {
                    if (quitDialog) {
                        quitDialog.style.display = 'none';
                    }
                }

                // Listen for IPC message to show quit dialog
                if (window.electronAPI && window.electronAPI.onShowQuitDialog) {
                    window.electronAPI.onShowQuitDialog(() => {
                        showQuitDialog();
                    });
                }

                // Handle button clicks
                if (quitCancelBtn) {
                    quitCancelBtn.addEventListener('click', () => {
                        hideQuitDialog();
                        if (window.electronAPI && window.electronAPI.cancelQuit) {
                            window.electronAPI.cancelQuit();
                        }
                    });
                }

                if (quitConfirmBtn) {
                    quitConfirmBtn.addEventListener('click', () => {
                        hideQuitDialog();
                        if (window.electronAPI && window.electronAPI.confirmQuit) {
                            window.electronAPI.confirmQuit();
                        }
                    });
                }

                // Close dialog on overlay click
                if (quitDialog) {
                    quitDialog.addEventListener('click', (e) => {
                        if (e.target === quitDialog) {
                            hideQuitDialog();
                            if (window.electronAPI && window.electronAPI.cancelQuit) {
                                window.electronAPI.cancelQuit();
                            }
                        }
                    });
                }

                // Handle Escape key to close dialog and Enter key to confirm
                document.addEventListener('keydown', (e) => {
                    if (quitDialog && quitDialog.style.display === 'flex') {
                        if (e.key === 'Escape') {
                            hideQuitDialog();
                            if (window.electronAPI && window.electronAPI.cancelQuit) {
                                window.electronAPI.cancelQuit();
                            }
                        } else if (e.key === 'Enter') {
                            hideQuitDialog();
                            if (window.electronAPI && window.electronAPI.confirmQuit) {
                                window.electronAPI.confirmQuit();
                            }
                        }
                    }
                });
            } catch (error) {
                console.error('Error initializing BrowserManager:', error);
            }
        });
    </script>

    <!-- Quit Confirmation Dialog -->
    <div id="quitDialog" class="quit-dialog-overlay" style="display: none;">
        <div class="quit-dialog">
            <div class="quit-dialog-icon">
                <svg width="64" height="64" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M18 6L6 18M6 6l12 12"/>
                </svg>
            </div>
            <h2 class="quit-dialog-title">Are you sure you want to quit?</h2>
            <p class="quit-dialog-message">All unsaved changes will be lost.</p>
            <div class="quit-dialog-buttons">
                <button id="quitCancelBtn" class="quit-dialog-btn quit-dialog-btn-cancel">Cancel</button>
                <button id="quitConfirmBtn" class="quit-dialog-btn quit-dialog-btn-quit">Quit</button>
            </div>
        </div>
    </div>
</body>
</html>
