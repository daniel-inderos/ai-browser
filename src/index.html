<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="AI Browser - Modern web browser with intelligent features">
    <title>AI Browser</title>
    <link rel="stylesheet" href="index.css">
    <!-- Markdown parser -->
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
</head>
<body>
    <div class="browser-container" role="application" aria-label="AI Browser">
        <!-- Hover trigger zone for collapsed sidebar -->
        <div class="hover-trigger-zone" id="hoverTriggerZone"></div>
        <!-- Left Tab Rail -->
        <aside class="tab-rail" aria-label="Tab Sidebar">
            <div class="tab-rail-header">
                <div class="incognito-indicator" id="incognitoIndicator" style="display: none;" title="Incognito Mode - Your browsing history won't be saved">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <!-- Sunglasses icon for incognito -->
                        <circle cx="7" cy="10" r="4" fill="currentColor" opacity="0.2"/>
                        <circle cx="17" cy="10" r="4" fill="currentColor" opacity="0.2"/>
                        <path d="M11 10h2"/>
                        <path d="M3 14c0 2 1.5 3 4 3h10c2.5 0 4-1 4-3"/>
                    </svg>
                    <span class="incognito-text">Incognito</span>
                </div>
            </div>
            <div class="rail-url">
                <div class="rail-url-controls">
                    <button class="nav-btn" id="backBtn" title="Go back (⌘←)" aria-label="Navigate back">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M19 12H5" />
                            <path d="M12 5l-7 7 7 7" />
                        </svg>
                    </button>
                    <button class="nav-btn" id="forwardBtn" title="Go forward (⌘→)" aria-label="Navigate forward">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M5 12h14" />
                            <path d="M12 5l7 7-7 7" />
                        </svg>
                    </button>
                    <button class="nav-btn" id="refreshBtn" title="Refresh page (⌘R)" aria-label="Refresh current page">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <polyline points="23 4 23 10 17 10" />
                            <polyline points="1 20 1 14 7 14" />
                            <path d="M3.51 9a9 9 0 0114.13-3.36L23 10" />
                            <path d="M20.49 15a9 9 0 01-14.13 3.36L1 14" />
                        </svg>
                    </button>
                    <button class="chat-btn" id="chatBtn" title="AI Chat (⌘E)" aria-label="Open AI Chat">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M21 15a2 2 0 01-2 2H7l-4 4V5a2 2 0 012-2h14a2 2 0 012 2z" />
                        </svg>
                    </button>
                    <button class="summarize-btn" id="summarizeBtn" title="Summarize Page" aria-label="Summarize current page">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <line x1="21" y1="6" x2="8" y2="6" />
                            <line x1="21" y1="12" x2="8" y2="12" />
                            <line x1="21" y1="18" x2="8" y2="18" />
                            <line x1="3" y1="6" x2="3" y2="6" />
                            <line x1="3" y1="12" x2="3" y2="12" />
                            <line x1="3" y1="18" x2="3" y2="18" />
                        </svg>
                    </button>
                </div>
                <div class="url-input-wrapper">
                    <input type="url" 
                           class="url-bar" 
                           id="urlBar" 
                           placeholder="Search or enter website URL..."
                           aria-label="Address bar"
                           autocomplete="url"
                           spellcheck="false">
                    <div class="url-suggestions" id="urlSuggestions" role="listbox" aria-label="URL suggestions"></div>
                </div>
                <div class="rail-url-actions">
                </div>
            </div>
            <button class="rail-new-tab-pill" id="railNewTabBtn" title="New Tab (⌘T)" aria-label="Open new tab">
                <span class="plus">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M12 4v16M20 12H4" />
                    </svg>
                </span>
                <span style="font-weight:600;">New Tab</span>
            </button>
            <div class="tab-rail-tabs" id="tabRailTabs" role="listbox" aria-label="Open Tabs"></div>
            <div class="sidebar-resizer tab-rail-resizer" id="tabRailResizer" role="separator" aria-orientation="vertical" aria-label="Resize tab sidebar" tabindex="0"></div>
        </aside>
        <!-- Hidden top tab bar kept only as logical container for existing code -->
        <div class="tab-bar" role="tablist" aria-label="Browser tabs" style="display:none">
            <div class="tabs-container" id="tabsContainer"></div>
        </div>

        <!-- AI Chat Sidebar -->
        <aside class="chat-sidebar" id="chatSidebar" role="complementary" aria-label="AI Chat Sidebar">
            <div class="sidebar-resizer chat-sidebar-resizer" id="chatSidebarResizer" role="separator" aria-orientation="vertical" aria-label="Resize AI chat sidebar" tabindex="0"></div>
            <div class="chat-history" id="chatHistory" tabindex="0" aria-live="polite" aria-atomic="false"></div>
            <div class="chat-input-area">
                <div id="contextPillsContainer" class="context-pills-container"></div>
                <form class="chat-input-container" id="chatInputForm" autocomplete="off">
                    <button type="button" class="chat-clear-btn" id="chatClearBtn" aria-label="Clear chat" title="Clear chat">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M3 6h18" />
                            <path d="M8 6v12a2 2 0 002 2h4a2 2 0 002-2V6" />
                            <line x1="10" y1="11" x2="14" y2="11" />
                            <line x1="10" y1="15" x2="14" y2="15" />
                        </svg>
                    </button>
                    <div class="chat-input-wrapper">
                        <input id="chatInput" class="chat-input" type="text" placeholder="Ask AI..." aria-label="Chat input" />
                        <div id="tabSuggestions" class="tab-suggestions"></div>
                    </div>
                    <button type="submit" class="chat-send-btn" id="chatSendBtn" aria-label="Send message">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <line x1="22" y1="2" x2="11" y2="13" />
                            <polygon points="22 2 15 22 11 13 2 9 22 2" />
                        </svg>
                    </button>
                </form>
            </div>
        </aside>

        <!-- Web Content Area -->
        <main class="content-area" id="contentArea" role="main" aria-label="Web content">
            <!-- Loading state -->
            <div class="loading-state" id="loadingState" style="display: none;">
                <div class="loading-indicator">
                    <div class="loading-spinner" aria-hidden="true"></div>
                    <span>Loading page...</span>
                </div>
            </div>
            
            <!-- Error state -->
            <div class="error-state" id="errorState" style="display: none;">
                <div class="error-page">
                    <svg width="48" height="48" viewBox="0 0 24 24" fill="var(--color-text-tertiary)" aria-hidden="true">
                        <path d="M12 9v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"/>
                    </svg>
                    <h2>Unable to load page</h2>
                    <p>Please check your internet connection and try again.</p>
                    <button class="retry-btn" id="retryBtn">Try Again</button>
                </div>
            </div>
            
            <!-- Web views will be dynamically added here -->
        </main>
    </div>

    <!-- Command Palette -->
    <div class="command-palette-backdrop" id="commandPaletteBackdrop">
        <div class="command-palette">
            <div class="command-palette-input-container">
                <div class="command-palette-mode-switcher">
                    <button class="command-palette-mode-btn active" id="commandPaletteModeSearch" data-mode="search">
                        <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <circle cx="11" cy="11" r="8"></circle>
                            <path d="M21 21l-4.35-4.35"></path>
                        </svg>
                        Search
                    </button>
                    <button class="command-palette-mode-btn" id="commandPaletteModeAsk" data-mode="ask">
                        <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M21 15a2 2 0 01-2 2H7l-4 4V5a2 2 0 012-2h14a2 2 0 012 2z"></path>
                        </svg>
                        Ask
                    </button>
                </div>
                <input 
                    type="text" 
                    class="command-palette-input" 
                    id="commandPaletteInput" 
                    placeholder="Search or Enter URL..."
                    autocomplete="off"
                    spellcheck="false"
                />
            </div>
            <div class="command-palette-results" id="commandPaletteResults"></div>
        </div>
    </div>

    <script>
        class BrowserManager {
            constructor() {
                this.tabs = [];
                this.activeTabId = null;
                this.tabCounter = 0;
                this.sidebarConstraints = {
                    tabRail: { min: 200, max: 420, default: 260 },
                    chatSidebar: { min: 260, max: 560, default: 320 }
                };
                this.activeResize = null;
                this.resizeAnimationFrame = null;
                this.rootStyle = document.documentElement.style;
                this.handleSidebarResize = this.handleSidebarResize.bind(this);
                this.stopSidebarResize = this.stopSidebarResize.bind(this);
                this.sidebarCollapsed = false;
                this.sidebarHoveredWhileCollapsed = false;
                
                this.initializeElements();
                this.setupResizableSidebars();
                this.setupEventListeners();
                this.createInitialTab();
                this.setupKeyboardShortcuts();
                this.chatSessions = new Map();
                this.marked = window.marked;
                
                // Ensure chat and summarize buttons are visible by default
                if (this.chatBtn) {
                    this.chatBtn.style.display = 'flex';
                }
                if (this.summarizeBtn) {
                    this.summarizeBtn.style.display = 'flex';
                }
                
                // Show incognito indicator if in incognito mode (async)
                this.checkIncognitoMode();
            }
            
            async checkIncognitoMode() {
                console.log('Checking incognito mode...');
                try {
                    const isIncognitoMode = await window.electronAPI.isIncognito();
                    console.log('isIncognito result:', isIncognitoMode);
                    
                    // Cache the incognito state
                    this.isIncognito = isIncognitoMode;
                    
                    if (isIncognitoMode && this.incognitoIndicator) {
                        console.log('Showing incognito indicator');
                        this.incognitoIndicator.style.display = 'flex';
                        // Update window title to show incognito mode
                        document.title = 'AI Browser (Incognito)';
                    } else {
                        console.log('NOT showing incognito indicator. isIncognito:', isIncognitoMode, 'indicator exists:', !!this.incognitoIndicator);
                    }
                } catch (error) {
                    console.error('Error checking incognito mode:', error);
                    this.isIncognito = false;
                }
            }

            getDisplayUrl(url) {
                return url || '';
            }

            initializeElements() {
                this.tabsContainer = document.getElementById('tabsContainer');
                this.newTabBtn = document.getElementById('railNewTabBtn');
                this.tabRailTabs = document.getElementById('tabRailTabs');
                this.railNewTabBtn = document.getElementById('railNewTabBtn');
                this.backBtn = document.getElementById('backBtn');
                this.forwardBtn = document.getElementById('forwardBtn');
                this.refreshBtn = document.getElementById('refreshBtn');
                this.urlBar = document.getElementById('urlBar');
                this.contentArea = document.getElementById('contentArea');
                this.loadingState = document.getElementById('loadingState');
                this.errorState = document.getElementById('errorState');
                this.retryBtn = document.getElementById('retryBtn');
                // References for showing/hiding the URL bar portion on the new-tab page
                this.navBar = document.querySelector('.nav-bar');
                this.urlBarContainer = document.querySelector('.url-bar-container');
                this.chatBtn = document.getElementById('chatBtn');
                this.summarizeBtn = document.getElementById('summarizeBtn');
                this.chatSidebar = document.getElementById('chatSidebar');
                this.chatInput = document.getElementById('chatInput');
                this.chatInputForm = document.getElementById('chatInputForm');
                this.chatHistory = document.getElementById('chatHistory');
                this.chatClearBtn = document.getElementById('chatClearBtn');
                this.contextPillsContainer = document.getElementById('contextPillsContainer');
                this.tabSuggestions = document.getElementById('tabSuggestions');
                this.tabRailResizer = document.getElementById('tabRailResizer');
                this.chatSidebarResizer = document.getElementById('chatSidebarResizer');
                this.tabRail = document.querySelector('.tab-rail');
                this.hoverTriggerZone = document.getElementById('hoverTriggerZone');
                this.incognitoIndicator = document.getElementById('incognitoIndicator');
                // Command palette elements
                this.commandPaletteBackdrop = document.getElementById('commandPaletteBackdrop');
                this.commandPaletteInput = document.getElementById('commandPaletteInput');
                this.commandPaletteResults = document.getElementById('commandPaletteResults');
                this.commandPaletteModeSearch = document.getElementById('commandPaletteModeSearch');
                this.commandPaletteModeAsk = document.getElementById('commandPaletteModeAsk');
                this.commandPaletteMode = 'search'; // Default mode
                this.selectedResultIndex = -1;

                // Listen for messages from webviews
                window.addEventListener('message', (e) => {
                    console.log('BrowserManager received message:', e.data);
                    console.log('BrowserManager received message from source:', e.source);
                    if (!e.data || !e.data.type) return;

                    // Handle shortcut messages from newtab.html
                    if (e.data.type === 'shortcut') {
                        switch (e.data.command) {
                            case 'close-tab':
                                this.closeActiveTab();
                                break;
                            case 'new-tab':
                                this.createTab();
                                break;
                            case 'focus-url':
                                if (!this.urlBarContainer || this.urlBarContainer.style.display !== 'none') {
                                    this.urlBar.focus();
                                }
                                break;
                        }
                    }

                    // Handle tab context requests from newtab.html
                    if (e.data.type === 'request-tabs') {
                        // Try to find sender by contentWindow; if not found, fall back to active newtab
                        let sourceWebview = this.tabs.find(tab => tab.webview && tab.webview.contentWindow === e.source);
                        if (!sourceWebview) {
                            sourceWebview = this.tabs.find(tab => tab.id === this.activeTabId && tab.url && tab.url.includes('newtab.html'));
                        }
                        if (sourceWebview) {
                            const tabData = this.tabs
                                .filter(t => t.id !== sourceWebview.id)
                                .map(t => ({ id: t.id, title: t.title, url: t.url }));

                        try {
                            // Send message to guest via IPC channel bridged by preload
                            sourceWebview.webview.send('guest-message', { type: 'tabs-response', tabs: tabData });
                        } catch (err) {
                            console.error('Failed to send tabs response:', err);
                        }
                        }
                    }

                    // Handle chat requests from newtab.html
                    if (e.data.type === 'new-tab-chat-send') {
                        console.log('Received new-tab-chat-send message:', e.data);
                        console.log('Handling new-tab-chat-send with data:', e.data);
                        // Find the source webview by checking if it contains newtab.html
                        const sourceWebview = this.tabs.find(tab => 
                            tab.url && tab.url.includes('newtab.html') && tab.id === this.activeTabId
                        );
                        if (sourceWebview) {
                            console.log('Found source webview, calling handleNewTabChat');
                            console.log('Source webview found:', sourceWebview.id);
                            this.handleNewTabChat(e.data, sourceWebview);
                        } else {
                            console.error('Could not find source webview for chat request');
                        }
                    }
                });
            }

            setupResizableSidebars() {
                if (!this.rootStyle) {
                    this.rootStyle = document.documentElement.style;
                }

                const savedTabRailWidth = this.getStoredSidebarWidth('tabRailWidth');
                if (savedTabRailWidth !== null) {
                    this.setTabRailWidth(savedTabRailWidth, false);
                }

                const savedChatSidebarWidth = this.getStoredSidebarWidth('chatSidebarWidth');
                if (savedChatSidebarWidth !== null) {
                    this.setChatSidebarWidth(savedChatSidebarWidth, false);
                }

                // Restore collapsed state from localStorage
                const savedCollapsedState = localStorage.getItem('sidebarCollapsed');
                if (savedCollapsedState === 'true') {
                    this.sidebarCollapsed = true;
                    this.tabRail.classList.add('collapsed');
                    this.hoverTriggerZone.classList.add('active');
                }

                if (this.tabRailResizer) {
                    this.tabRailResizer.addEventListener('pointerdown', (event) => this.startSidebarResize('tabRail', event));
                    this.tabRailResizer.addEventListener('keydown', (event) => this.handleResizerKeydown('tabRail', event));
                }

                if (this.chatSidebarResizer) {
                    this.chatSidebarResizer.addEventListener('pointerdown', (event) => this.startSidebarResize('chatSidebar', event));
                    this.chatSidebarResizer.addEventListener('keydown', (event) => this.handleResizerKeydown('chatSidebar', event));
                }

                // Setup hover behavior for collapsed sidebar
                if (this.hoverTriggerZone && this.tabRail) {
                    this.hoverTriggerZone.addEventListener('mouseenter', () => {
                        if (this.sidebarCollapsed) {
                            this.sidebarHoveredWhileCollapsed = true;
                            this.tabRail.classList.remove('collapsed');
                        }
                    });

                    this.tabRail.addEventListener('mouseleave', () => {
                        if (this.sidebarCollapsed && this.sidebarHoveredWhileCollapsed) {
                            this.sidebarHoveredWhileCollapsed = false;
                            this.tabRail.classList.add('collapsed');
                        }
                    });
                }

                this.updateContentAreaWidth();
            }

            getStoredSidebarWidth(key) {
                try {
                    const stored = localStorage.getItem(key);
                    if (stored) {
                        const parsed = parseInt(stored, 10);
                        if (!Number.isNaN(parsed)) {
                            return parsed;
                        }
                    }
                } catch (error) {
                    console.warn('Failed to read stored sidebar width:', error);
                }
                return null;
            }

            startSidebarResize(sidebar, event) {
                if (event.button !== undefined && event.button !== 0) return;
                event.preventDefault();
                const clientX = event.clientX;
                if (typeof clientX !== 'number') return;

                document.body.classList.add('sidebar-resizing');

                const initialWidth = this.getCurrentSidebarWidth(sidebar);
                this.activeResize = {
                    sidebar,
                    startX: clientX,
                    initialWidth,
                    lastWidth: initialWidth,
                    handleElement: event.currentTarget
                };

                if (this.activeResize.handleElement) {
                    this.activeResize.handleElement.classList.add('dragging');
                    if (event.pointerId != null && this.activeResize.handleElement.setPointerCapture) {
                        try {
                            this.activeResize.handleElement.setPointerCapture(event.pointerId);
                        } catch (_) {}
                    }
                }

                document.addEventListener('pointermove', this.handleSidebarResize);
                document.addEventListener('pointerup', this.stopSidebarResize);
                document.addEventListener('pointercancel', this.stopSidebarResize);
            }

            handleSidebarResize(event) {
                if (!this.activeResize) return;
                event.preventDefault();
                const clientX = event.clientX;
                if (typeof clientX !== 'number') return;

                // Cancel any pending animation frame
                if (this.resizeAnimationFrame) {
                    cancelAnimationFrame(this.resizeAnimationFrame);
                }

                // Schedule resize update for next animation frame
                this.resizeAnimationFrame = requestAnimationFrame(() => {
                    let newWidth = this.activeResize.initialWidth;
                    if (this.activeResize.sidebar === 'tabRail') {
                        newWidth = this.clampWidth(
                            this.activeResize.initialWidth + (clientX - this.activeResize.startX),
                            this.sidebarConstraints.tabRail.min,
                            this.sidebarConstraints.tabRail.max
                        );
                        this.setTabRailWidth(newWidth, false);
                    } else {
                        newWidth = this.clampWidth(
                            this.activeResize.initialWidth + (this.activeResize.startX - clientX),
                            this.sidebarConstraints.chatSidebar.min,
                            this.sidebarConstraints.chatSidebar.max
                        );
                        this.setChatSidebarWidth(newWidth, false);
                    }

                    this.activeResize.lastWidth = newWidth;
                    this.resizeAnimationFrame = null;
                });
            }

            stopSidebarResize(event) {
                if (!this.activeResize) return;

                // Cancel any pending animation frame
                if (this.resizeAnimationFrame) {
                    cancelAnimationFrame(this.resizeAnimationFrame);
                    this.resizeAnimationFrame = null;
                }

                const finalWidth = this.activeResize.lastWidth;

                if (typeof finalWidth === 'number') {
                    if (this.activeResize.sidebar === 'tabRail') {
                        this.setTabRailWidth(finalWidth);
                    } else {
                        this.setChatSidebarWidth(finalWidth);
                    }
                }

                if (this.activeResize.handleElement) {
                    this.activeResize.handleElement.classList.remove('dragging');
                    if (event && event.pointerId != null && this.activeResize.handleElement.releasePointerCapture) {
                        try {
                            this.activeResize.handleElement.releasePointerCapture(event.pointerId);
                        } catch (_) {}
                    }
                }

                this.activeResize = null;
                document.removeEventListener('pointermove', this.handleSidebarResize);
                document.removeEventListener('pointerup', this.stopSidebarResize);
                document.removeEventListener('pointercancel', this.stopSidebarResize);

                document.body.classList.remove('sidebar-resizing');
            }

            handleResizerKeydown(sidebar, event) {
                if (event.key !== 'ArrowLeft' && event.key !== 'ArrowRight') return;
                const step = event.shiftKey ? 20 : 10;

                if (sidebar === 'tabRail') {
                    const delta = event.key === 'ArrowLeft' ? -step : step;
                    this.setTabRailWidth(this.getCurrentSidebarWidth('tabRail') + delta);
                } else {
                    const delta = event.key === 'ArrowLeft' ? step : -step;
                    this.setChatSidebarWidth(this.getCurrentSidebarWidth('chatSidebar') + delta);
                }

                event.preventDefault();
            }

            setTabRailWidth(width, persist = true) {
                const clamped = this.clampWidth(
                    width,
                    this.sidebarConstraints.tabRail.min,
                    this.sidebarConstraints.tabRail.max
                );

                if (this.rootStyle) {
                    this.rootStyle.setProperty('--tab-rail-width', `${clamped}px`);
                }

                if (persist) {
                    this.persistSidebarWidth('tabRailWidth', clamped);
                    // Only update content area when persisting (not during active resize)
                    this.updateContentAreaWidth();
                }

                return clamped;
            }

            setChatSidebarWidth(width, persist = true) {
                const clamped = this.clampWidth(
                    width,
                    this.sidebarConstraints.chatSidebar.min,
                    this.sidebarConstraints.chatSidebar.max
                );

                if (this.rootStyle) {
                    this.rootStyle.setProperty('--chat-sidebar-width', `${clamped}px`);
                }

                if (persist) {
                    this.persistSidebarWidth('chatSidebarWidth', clamped);
                    // Only update content area when persisting (not during active resize)
                    this.updateContentAreaWidth();
                }

                return clamped;
            }

            persistSidebarWidth(key, value) {
                try {
                    localStorage.setItem(key, String(value));
                } catch (error) {
                    console.warn('Failed to persist sidebar width:', error);
                }
            }

            getCurrentSidebarWidth(sidebar) {
                const varName = sidebar === 'tabRail' ? '--tab-rail-width' : '--chat-sidebar-width';
                const constraints = sidebar === 'tabRail' ? this.sidebarConstraints.tabRail : this.sidebarConstraints.chatSidebar;
                const computed = getComputedStyle(document.documentElement).getPropertyValue(varName);
                const parsed = parseInt(computed, 10);
                if (!Number.isNaN(parsed)) {
                    return parsed;
                }
                return constraints.default;
            }

            clampWidth(value, min, max) {
                return Math.min(Math.max(value, min), max);
            }

            updateContentAreaWidth() {
                // Width is now handled by CSS :has() selectors based on chat-sidebar.open class
                // No need to set inline styles which cause layout thrashing
            }

            toggleSidebarCollapse() {
                this.sidebarCollapsed = !this.sidebarCollapsed;
                
                if (this.sidebarCollapsed) {
                    this.tabRail.classList.add('collapsed');
                    this.hoverTriggerZone.classList.add('active');
                } else {
                    this.tabRail.classList.remove('collapsed');
                    this.hoverTriggerZone.classList.remove('active');
                    this.sidebarHoveredWhileCollapsed = false;
                }
                
                // Persist state to localStorage
                localStorage.setItem('sidebarCollapsed', this.sidebarCollapsed.toString());
                
                this.updateContentAreaWidth();
            }

            async handleNewTabChat(data, sourceTab) {
                console.log('handleNewTabChat called with:', data);
                console.log('handleNewTabChat starting for reqId:', data.reqId);
                const { reqId, session, referencedTabIds } = data;
                const contexts = [];

                for (const tabId of referencedTabIds) {
                    const referencedTab = this.tabs.find(t => t.id === tabId);
                    if (referencedTab) {
                        try {
                            const context = await this.getPageContext(referencedTab);
                            if (context) {
                                console.log('Got context for tab:', tabId);
                                contexts.push(context);
                            }
                        } catch (err) {
                            console.error(`Failed to get page context for tab ${tabId}:`, err);
                        }
                    }
                }

                console.log('Sending chat request with contexts:', contexts.length);
                console.log('Sending to electronAPI.sendChat');
                const streamHandler = (streamData) => {
                    console.log('Received stream data:', streamData);
                    console.log('Stream handler called with:', streamData);
                    // Only handle responses for this request and forward to the source webview
                    if (streamData.id === reqId) {
                        // Forward streamed chat data to the webview
                        try {
                            const payload = { type: 'chat-stream-response', ...streamData };
                            console.log('Forwarding stream to webview via send(channel):', payload);
                            sourceTab.webview.send('guest-message', payload);
                        } catch (err) {
                            console.error('Failed to send message to webview via send:', err);
                        }
                        
                        if (streamData.done || streamData.error) {
                            // Clean up listener after completion or error
                            console.log('Stream done or error, removing listener');
                            window.electronAPI.removeListener('chat-stream', streamHandler);
                        }
                    }
                };

                // Ensure we don't have duplicate listeners; add before sending to avoid race
                console.log('Adding chat-stream listener');
                window.electronAPI.onChatStream(streamHandler);

                try {
                    // Fire and forget so we don't miss early tokens
                    window.electronAPI.sendChat(reqId, session, contexts);
                } catch (error) {
                    console.error('Error sending chat request:', error);
                    // Send error back to newtab immediately
                    try {
                        sourceTab.webview.send('guest-message', { type: 'chat-stream-response', id: reqId, error: error.message });
                    } catch (e2) {
                        console.error('Failed to send error to guest:', e2);
                    }
                }
            }

            setupEventListeners() {
                // Tab management - show command palette instead of creating tab directly
                this.newTabBtn.addEventListener('click', () => this.showCommandPalette());
                
                // Navigation
                this.backBtn.addEventListener('click', () => this.navigateBack());
                this.forwardBtn.addEventListener('click', () => this.navigateForward());
                this.refreshBtn.addEventListener('click', () => this.refreshPage());
                this.retryBtn.addEventListener('click', () => this.refreshPage());
                
                // Command palette event listeners
                this.commandPaletteBackdrop.addEventListener('click', (e) => {
                    if (e.target === this.commandPaletteBackdrop) {
                        this.hideCommandPalette();
                    }
                });
                
                this.commandPaletteModeSearch.addEventListener('click', () => {
                    this.setCommandPaletteMode('search');
                });
                
                this.commandPaletteModeAsk.addEventListener('click', () => {
                    this.setCommandPaletteMode('ask');
                });
                
                this.commandPaletteInput.addEventListener('input', () => {
                    this.updateCommandPaletteResults();
                });
                
                this.commandPaletteInput.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        this.executeCommandPaletteAction();
                    } else if (e.key === 'Escape') {
                        e.preventDefault();
                        this.hideCommandPalette();
                    } else if (e.key === 'ArrowDown') {
                        e.preventDefault();
                        this.selectNextResult();
                    } else if (e.key === 'ArrowUp') {
                        e.preventDefault();
                        this.selectPreviousResult();
                    } else if (e.key === 'Tab') {
                        e.preventDefault();
                        // Switch between Search and Ask modes
                        const newMode = this.commandPaletteMode === 'search' ? 'ask' : 'search';
                        this.setCommandPaletteMode(newMode);
                    }
                });
                
                // URL bar
                this.urlBar.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        this.navigateToUrl();
                    }
                });

                // URL bar text selection with improved UX
                this.urlBar.addEventListener('focus', () => {
                    this.urlBar.select();
                });

                // Enhanced click behavior
                this.urlBar.addEventListener('click', (e) => {
                    if (this.urlBar.selectionStart === this.urlBar.selectionEnd) {
                        this.urlBar.select();
                    }
                });

                // Chat button
                if (this.chatBtn) {
                    this.chatBtn.addEventListener('click', () => this.toggleChatSidebar());
                }

                // Summarize button
                if (this.summarizeBtn) {
                    this.summarizeBtn.addEventListener('click', () => this.handleSummarizePage());
                }

                // Chat form submission
                if (this.chatInputForm) {
                    this.chatInputForm.addEventListener('submit', (e) => {
                        e.preventDefault();
                        this.handleChatSend();
                    });
                }
                if (this.chatClearBtn) {
                    this.chatClearBtn.addEventListener('click', () => this.clearChat());
                }

                this.chatInput.addEventListener('input', () => this.handleChatInput());
                this.chatInput.addEventListener('keydown', (e) => this.handleSuggestionKeyboardNav(e));
                this.tabSuggestions.addEventListener('click', (e) => this.handleSuggestionClick(e));

                // Electron menu shortcuts
                // From menu/global accelerator
                window.electronAPI.onNewTab(() => {
                    this.showCommandPalette();
                });
                window.electronAPI.onCloseTab(() => this.closeActiveTab());
                window.electronAPI.onNavigateBack(() => this.navigateBack());
                window.electronAPI.onNavigateForward(() => this.navigateForward());
                window.electronAPI.onRefreshPage(() => this.refreshPage());
                // Global accelerators that must work when webview is focused
                window.electronAPI.onFocusUrl(() => {
                    if (!this.urlBarContainer || this.urlBarContainer.style.display !== 'none') {
                        this.urlBar.focus();
                    }
                });
                window.electronAPI.onToggleChat(() => this.toggleChatSidebar());
                window.electronAPI.onToggleSidebar(() => this.toggleSidebarCollapse());
                // Tab numeric selection from menu accelerators
                window.electronAPI.onSelectTab(({ index }) => this.selectTabByNumber(index));
                window.electronAPI.onShowHistory(() => this.showHistory());

                // Window resize handling
                window.addEventListener('resize', this.debounce(() => {
                    this.updateLayout();
                }, 250));
            }

            setupKeyboardShortcuts() {
                document.addEventListener('keydown', (e) => {
                    // Handle keyboard shortcuts
                    if (e.metaKey || e.ctrlKey) {
                        switch (e.key) {
                            case 't':
                                e.preventDefault();
                                this.showCommandPalette();
                                break;
                            case 'w':
                                e.preventDefault();
                                this.closeActiveTab();
                                break;
                            case 'r':
                                e.preventDefault();
                                this.refreshPage();
                                break;
                            case 'l':
                                e.preventDefault();
                                this.urlBar.focus();
                                break;
                            case 'e':
                                e.preventDefault();
                                this.toggleChatSidebar();
                                break;
                            case 's':
                                e.preventDefault();
                                this.toggleSidebarCollapse();
                                break;
                            case 'y':
                                e.preventDefault();
                                this.showHistory();
                                break;
                            default: {
                                // Number keys 1-9 to switch tabs like Chrome
                                if (/^[1-9]$/.test(e.key)) {
                                    e.preventDefault();
                                    this.selectTabByNumber(parseInt(e.key, 10));
                                }
                                break;
                            }
                        }
                    }
                });
            }


            selectTabByNumber(n) {
                if (!this.tabs.length) return;
                // Chrome behavior: 1-8 go to that index; 9 goes to last tab
                let targetIndex = n === 9 ? this.tabs.length - 1 : n - 1;
                if (targetIndex < 0) targetIndex = 0;
                if (targetIndex >= this.tabs.length) return; // Ignore if beyond tab count (except 9 handled above)
                const targetTab = this.tabs[targetIndex];
                if (targetTab) this.switchToTab(targetTab.id);
            }

            debounce(func, wait) {
                let timeout;
                return function executedFunction(...args) {
                    const later = () => {
                        clearTimeout(timeout);
                        func(...args);
                    };
                    clearTimeout(timeout);
                    timeout = setTimeout(later, wait);
                };
            }

            updateLayout() {
                // Handle any layout updates needed on resize
                this.tabs.forEach(tab => {
                    if (tab.webview) {
                        // Webviews automatically handle resize
                    }
                });
            }

            // Show or hide the navigation bar depending on the active URL
            updateNavBarVisibility(url) {
                if (!this.urlBarContainer) return;
                // URL bar now lives in the sidebar and should stay visible
                this.urlBarContainer.style.display = 'flex';
            }

            async createTab(url = 'https://www.google.com') {
                const preloadPath = await window.electronAPI.getPreloadPath();
                console.log('createTab called with url:', url);
                const tabId = `tab-${++this.tabCounter}`;
                
                // Create tab object
                const tab = {
                    id: tabId,
                    url: url,
                    title: 'New Tab',
                    webview: null,
                    isLoading: false,
                    chatSidebarOpen: false, // Track chat sidebar state per tab
                    referencedTabs: new Set(), // Store IDs of all context tabs
                    railElement: null,
                    railTitle: null,
                    railFavicon: null,
                };

                // Create enhanced tab UI with better accessibility
                const tabElement = document.createElement('div');
                tabElement.className = 'tab';
                tabElement.setAttribute('data-tab-id', tabId);
                tabElement.setAttribute('role', 'tab');
                tabElement.setAttribute('aria-selected', 'false');
                tabElement.setAttribute('tabindex', '-1');
                
                const tabTitle = document.createElement('span');
                tabTitle.className = 'tab-title';
                tabTitle.textContent = 'New Tab';
                tabTitle.setAttribute('aria-label', 'Tab title');
                
                const tabFavicon = document.createElement('img');
                tabFavicon.className = 'tab-favicon';
                // Use empty src initially; will update once favicon arrives
                tabFavicon.alt = '';
                
                // Helper to set AI logo for newtab.html
                const setAIIcon = () => {
                    // Detect dark mode
                    const isDarkMode = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
                    const iconColor = isDarkMode ? '#60A5FA' : '#2563EB'; // Blue-400 for dark, Blue-600 for light
                    
                    // AI sparkle icon - represents AI intelligence
                    const aiIconSVG = 'data:image/svg+xml,' + encodeURIComponent(`
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                            <path d="M12 2L13.5 8.5L20 10L13.5 11.5L12 18L10.5 11.5L4 10L10.5 8.5L12 2Z" fill="${iconColor}"/>
                        </svg>
                    `);
                    tabFavicon.src = aiIconSVG;
                    if (tab.railFavicon) tab.railFavicon.src = aiIconSVG;
                };
                
                // Helper to set favicon through fallback when direct event missing
                const updateFaviconFallback = async () => {
                    try {
                        // Try to find <link rel="icon"> inside the page
                        const candidate = await webview.executeJavaScript(`(() => {
                            const relIcons = Array.from(document.querySelectorAll('link[rel~="icon"]'));
                            if (relIcons.length) return relIcons[0].href || null;
                            return null;
                        })()`, true);
                        let iconUrl = candidate;
                        if (iconUrl) {
                            // Resolve relative paths
                            if (iconUrl.startsWith('/')) {
                                try {
                                    iconUrl = new URL(iconUrl, webview.getURL()).href;
                                } catch (err) {}
                            }
                            tabFavicon.src = iconUrl;
                            if (tab.railFavicon) tab.railFavicon.src = iconUrl;
                        } else {
                            // Check if this is newtab.html and use AI icon
                            const currentUrl = webview.getURL();
                            if (currentUrl && currentUrl.includes('newtab.html')) {
                                setAIIcon();
                            } else {
                                // Use Google favicon service as final fallback
                                try {
                                    const pageOrigin = new URL(webview.getURL()).origin;
                                    const fallback = `https://www.google.com/s2/favicons?sz=32&domain_url=${encodeURIComponent(pageOrigin)}`;
                                    tabFavicon.src = fallback;
                                    if (tab.railFavicon) tab.railFavicon.src = fallback;
                                } catch (err) {}
                            }
                        }
                    } catch (err) {
                        console.error('Failed to fetch favicon via fallback:', err);
                    }
                };

                const closeBtn = document.createElement('button');
                closeBtn.className = 'tab-close-btn';
                closeBtn.setAttribute('aria-label', 'Close tab');
                closeBtn.setAttribute('title', 'Close tab (⌘W)');
                closeBtn.innerHTML = `
                    <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <line x1="18" y1="6" x2="6" y2="18" />
                        <line x1="6" y1="6" x2="18" y2="18" />
                    </svg>
                `;
                closeBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    this.closeTab(tabId);
                });

                tabElement.appendChild(tabTitle);
                tabElement.appendChild(tabFavicon);
                // Ensure favicon appears before the title for better UX
                if (tabElement.contains(tabTitle)) {
                    tabElement.insertBefore(tabFavicon, tabTitle);
                }
                tabElement.appendChild(closeBtn);
                
                tabElement.addEventListener('click', () => this.switchToTab(tabId));
                tabElement.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter' || e.key === ' ') {
                        e.preventDefault();
                        this.switchToTab(tabId);
                    }
                });
                
                this.tabsContainer.appendChild(tabElement);

                // Create matching item in the left rail
                if (this.tabRailTabs) {
                    const railElement = document.createElement('div');
                    railElement.className = 'rail-tab';
                    railElement.setAttribute('data-tab-id', tabId);
                    railElement.setAttribute('role', 'option');
                    railElement.setAttribute('aria-selected', 'false');

                    const railFavicon = document.createElement('img');
                    railFavicon.className = 'rail-favicon';
                    railFavicon.alt = '';

                    const railTitle = document.createElement('span');
                    railTitle.className = 'rail-title';
                    railTitle.textContent = 'New Tab';

                    const railCloseBtn = document.createElement('button');
                    railCloseBtn.className = 'rail-close-btn';
                    railCloseBtn.setAttribute('aria-label', 'Close tab');
                    railCloseBtn.setAttribute('title', 'Close tab (⌘W)');
                    railCloseBtn.innerHTML = `
                        <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <line x1="18" y1="6" x2="6" y2="18" />
                            <line x1="6" y1="6" x2="18" y2="18" />
                        </svg>
                    `;
                    railCloseBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        this.closeTab(tabId);
                    });

                    railElement.appendChild(railFavicon);
                    railElement.appendChild(railTitle);
                    railElement.appendChild(railCloseBtn);

                    railElement.addEventListener('click', () => this.switchToTab(tabId));
                    railElement.addEventListener('keydown', (e) => {
                        if (e.key === 'Enter' || e.key === ' ') {
                            e.preventDefault();
                            this.switchToTab(tabId);
                        }
                    });

                    this.tabRailTabs.appendChild(railElement);

                    tab.railElement = railElement;
                    tab.railTitle = railTitle;
                    tab.railFavicon = railFavicon;
                }

                // Create webview with enhanced loading states
                const webview = document.createElement('webview');
                webview.style.display = 'none';
                // Note: removed webview.src = url;
                webview.setAttribute('allowpopups', '');
                webview.setAttribute('webpreferences', 'contextIsolation=true');
                webview.setAttribute('preload', `file://${preloadPath}`);
                webview.setAttribute('useragent', 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36 AI-Browser/1.0');
                // Use the partition from the parent window (shared across all tabs in incognito)
                const partition = await window.electronAPI.getPartition();
                webview.setAttribute('partition', partition);
                const result = await window.electronAPI.navigateTo(url);
                console.log('navigateTo result:', result);
                if (result.success) {
                  tab.url = result.url;
                  webview.setAttribute('src', result.url); // Set src instead of loadURL
                  
                  // Set AI icon immediately for newtab.html
                  if (result.url.includes('newtab.html')) {
                      setAIIcon();
                  }
                } else {
                  console.error('Navigation failed:', result.error);
                }

                // Enhanced webview event handling
                webview.addEventListener('dom-ready', () => {
                    try {
                        tab.title = webview.getTitle() || 'New Tab';
                        tabTitle.textContent = tab.title;
                        tabTitle.setAttribute('title', tab.title);
                        if (tab.railTitle) {
                            tab.railTitle.textContent = tab.title;
                            tab.railTitle.setAttribute('title', tab.title);
                        }
                        if (this.activeTabId === tabId) {
                            this.urlBar.value = this.getDisplayUrl(webview.getURL());
                            this.hideLoading();
                            // Always show chat and summarize buttons
                            if (this.chatBtn) {
                                this.chatBtn.style.display = 'flex';
                            }
                            if (this.summarizeBtn) {
                                this.summarizeBtn.style.display = 'flex';
                            }
                        }
                    } catch (error) {
                        console.error('Error in dom-ready handler:', error);
                    }
                });

                // Handle messages coming from newtab.html via ipcRenderer.sendToHost
                webview.addEventListener('ipc-message', (event) => {
                    try {
                        if (!event || !event.channel) return;
                        const channel = event.channel;
                        const arg = (event.args && event.args[0]) || {};
                        if (channel === 'request-tabs') {
                            const tabData = this.tabs
                                .filter(t => t.id !== tab.id)
                                .map(t => ({ id: t.id, title: t.title, url: t.url }));
                            try {
                                webview.send('guest-message', { type: 'tabs-response', tabs: tabData });
                            } catch (err) {
                                console.error('Failed to send tabs response (ipc):', err);
                            }
                        }
                        if (channel === 'new-tab-chat-send') {
                            const data = { type: 'new-tab-chat-send', ...arg };
                            this.handleNewTabChat(data, tab);
                        }
                        if (channel === 'update-title') {
                            // Update tab title and URL bar when newtab sends title update
                            const newTitle = arg.title || 'New Tab';
                            tab.title = newTitle;
                            if (tab.tabTitle) {
                                tab.tabTitle.textContent = newTitle;
                                tab.tabTitle.setAttribute('title', newTitle);
                            }
                            if (tab.railTitle) {
                                tab.railTitle.textContent = newTitle;
                                tab.railTitle.setAttribute('title', newTitle);
                            }
                            if (this.activeTabId === tab.id) {
                                this.urlBar.value = newTitle;
                            }
                            // Ensure AI icon is set for newtab
                            if (tab.url && tab.url.includes('newtab.html')) {
                                // Detect dark mode
                                const isDarkMode = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
                                const iconColor = isDarkMode ? '#60A5FA' : '#2563EB'; // Blue-400 for dark, Blue-600 for light
                                
                                const aiIconSVG = 'data:image/svg+xml,' + encodeURIComponent(`
                                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                                        <path d="M12 2L13.5 8.5L20 10L13.5 11.5L12 18L10.5 11.5L4 10L10.5 8.5L12 2Z" fill="${iconColor}"/>
                                    </svg>
                                `);
                                if (tab.tabFavicon) tab.tabFavicon.src = aiIconSVG;
                                if (tab.railFavicon) tab.railFavicon.src = aiIconSVG;
                            }
                        }
                        if (channel === 'shortcut') {
                            switch (arg.command) {
                                case 'close-tab':
                                    this.closeTab(tab.id);
                                    break;
                                case 'new-tab':
                                    this.showCommandPalette();
                                    break;
                                case 'focus-url':
                                    if (!this.urlBarContainer || this.urlBarContainer.style.display !== 'none') {
                                        this.urlBar.focus();
                                    }
                                    break;
                                case 'refresh-page':
                                    this.refreshPage();
                                    break;
                                case 'toggle-chat':
                                    this.toggleChatSidebar();
                                    break;
                                default:
                                    break;
                            }
                        }
                    } catch (e) {
                        console.error('ipc-message handler error:', e);
                    }
                });

                webview.addEventListener('page-title-updated', (_event) => {
                    const newTitle = webview.getTitle() || 'New Tab';
                    tab.title = newTitle;
                    tabTitle.textContent = newTitle;
                    tabTitle.setAttribute('title', newTitle);
                    if (tab.railTitle) {
                        tab.railTitle.textContent = newTitle;
                        tab.railTitle.setAttribute('title', newTitle);
                    }
                });
                // Add listener to capture page favicon changes
                webview.addEventListener('page-favicon-updated', async (event) => {
                    if (event.favicons && event.favicons.length > 0) {
                        tabFavicon.src = event.favicons[0];
                        if (tab.railFavicon) tab.railFavicon.src = event.favicons[0];
                    } else {
                        // If favicon still empty, attempt fallback
                        await updateFaviconFallback();
                    }
                });

                webview.addEventListener('did-navigate', (e) => {
                    tab.url = e.url;
                    // Clear favicon when navigating to new main page
                    tabFavicon.src = '';
                    if (tab.railFavicon) tab.railFavicon.src = '';
                    if (this.activeTabId === tabId) {
                        this.urlBar.value = this.getDisplayUrl(e.url);
                        this.updateNavBarVisibility(e.url);
                    }
                });

                webview.addEventListener('did-navigate-in-page', (e) => {
                    tab.url = e.url;
                    // Clear favicon for in-page navigations too (e.g., SPA route changes)
                    tabFavicon.src = '';
                    if (tab.railFavicon) tab.railFavicon.src = '';
                    if (this.activeTabId === tabId) {
                        this.urlBar.value = this.getDisplayUrl(e.url);
                        this.updateNavBarVisibility(e.url);
                    }
                });

                webview.addEventListener('did-fail-load', (e) => {
                    console.error('Page failed to load:', e);
                    if (e.errorCode !== -3 && this.activeTabId === tabId) { 
                        this.showError();
                    }
                    tab.isLoading = false;
                });

                webview.addEventListener('did-start-loading', () => {
                    tab.isLoading = true;
                    tabTitle.textContent = 'Loading...';
                    if (tab.railTitle) tab.railTitle.textContent = 'Loading...';
                    // Removed favicon reset here to avoid flicker; handled on navigation
                    if (this.activeTabId === tabId) {
                        this.showLoading();
                    }
                });

                webview.addEventListener('did-stop-loading', async () => {
                    tab.isLoading = false;
                    const finalTitle = webview.getTitle() || tab.title;
                    tab.title = finalTitle;
                    tabTitle.textContent = finalTitle;
                    tabTitle.setAttribute('title', finalTitle);
                    if (tab.railTitle) {
                        tab.railTitle.textContent = finalTitle;
                        tab.railTitle.setAttribute('title', finalTitle);
                    }
                    // If favicon still empty, attempt fallback
                    if (!tabFavicon.src) {
                        await updateFaviconFallback();
                    }
                    
                    // Save to history
                    const currentUrl = webview.getURL();
                    if (currentUrl && currentUrl.startsWith('http')) {
                        this.saveHistoryEntry(currentUrl, finalTitle, tabFavicon.src || '');
                    }
                    
                    if (this.activeTabId === tabId) {
                        this.hideLoading();
                    }
                });

                this.contentArea.appendChild(webview);
                tab.webview = webview;
                tab.tabElement = tabElement;
                tab.tabTitle = tabTitle;
                tab.tabFavicon = tabFavicon;

                this.tabs.push(tab);
                // Initialize empty chat session for this tab
                if (!this.chatSessions.has(tabId)) {
                    this.chatSessions.set(tabId, []);
                }

                // When the webview is ready, perform the full switch if it's the active tab.
                // This prevents race conditions where we try to execute JS before the page is loaded.
                webview.addEventListener('dom-ready', () => {
                    if (this.activeTabId === tabId) {
                        this.switchToTab(tabId);
                    }
                }, { once: true });

                // Always focus the newly created tab
                this.switchToTab(tabId);

                return tab;
            }

            showLoading() {
                this.loadingState.style.display = 'flex';
                this.errorState.style.display = 'none';
            }

            hideLoading() {
                this.loadingState.style.display = 'none';
            }

            showError() {
                this.loadingState.style.display = 'none';
                this.errorState.style.display = 'flex';
            }

            // Command Palette Methods
            showCommandPalette() {
                this.commandPaletteInput.value = '';
                this.selectedResultIndex = -1;
                this.commandPaletteBackdrop.classList.add('active');
                this.updateCommandPaletteResults();
                // Use setTimeout to ensure the backdrop is visible before focusing
                setTimeout(() => {
                    this.commandPaletteInput.focus();
                }, 50);
            }

            hideCommandPalette() {
                this.commandPaletteBackdrop.classList.remove('active');
                this.commandPaletteInput.value = '';
                this.selectedResultIndex = -1;
                this.commandPaletteResults.innerHTML = '';
            }

            setCommandPaletteMode(mode) {
                this.commandPaletteMode = mode;
                
                if (mode === 'search') {
                    this.commandPaletteModeSearch.classList.add('active');
                    this.commandPaletteModeAsk.classList.remove('active');
                    this.commandPaletteInput.placeholder = 'Search or Enter URL...';
                } else {
                    this.commandPaletteModeSearch.classList.remove('active');
                    this.commandPaletteModeAsk.classList.add('active');
                    this.commandPaletteInput.placeholder = 'Ask a question...';
                }
                
                this.updateCommandPaletteResults();
                this.commandPaletteInput.focus();
            }

            updateCommandPaletteResults() {
                const query = this.commandPaletteInput.value.trim().toLowerCase();
                const results = [];
                
                // Add open tabs
                this.tabs.forEach(tab => {
                    if (tab.id !== this.activeTabId && 
                        (!query || tab.title.toLowerCase().includes(query) || tab.url.toLowerCase().includes(query))) {
                        results.push({
                            type: 'tab',
                            title: tab.title,
                            url: tab.url,
                            favicon: tab.railFavicon ? tab.railFavicon.src : '',
                            action: 'Switch to Tab',
                            data: tab
                        });
                    }
                });
                
                // Add search suggestions if there's a query
                if (query && query.length > 0) {
                    results.push({
                        type: 'search',
                        title: `Search "${this.commandPaletteInput.value.trim()}"`,
                        url: `google.com/search?q=${encodeURIComponent(this.commandPaletteInput.value.trim())}`,
                        favicon: 'https://www.google.com/favicon.ico',
                        action: 'Search',
                        data: null
                    });
                }
                
                // Show results
                this.renderCommandPaletteResults(results);
            }

            renderCommandPaletteResults(results) {
                this.commandPaletteResults.innerHTML = '';
                
                if (results.length === 0 && this.commandPaletteInput.value.trim()) {
                    // Show "search web" option
                    const item = document.createElement('div');
                    item.className = 'command-palette-result-item';
                    item.innerHTML = `
                        <div class="command-palette-result-favicon"></div>
                        <div class="command-palette-result-content">
                            <div class="command-palette-result-title">Search the web</div>
                            <div class="command-palette-result-url">Press Enter to search</div>
                        </div>
                    `;
                    item.addEventListener('click', () => this.executeCommandPaletteAction());
                    this.commandPaletteResults.appendChild(item);
                } else {
                    results.forEach((result, index) => {
                        const item = document.createElement('div');
                        item.className = 'command-palette-result-item';
                        if (index === this.selectedResultIndex) {
                            item.classList.add('selected');
                        }
                        
                        const faviconHtml = result.favicon 
                            ? `<img src="${result.favicon}" class="command-palette-result-favicon" />`
                            : '<div class="command-palette-result-favicon"></div>';
                        
                        item.innerHTML = `
                            ${faviconHtml}
                            <div class="command-palette-result-content">
                                <div class="command-palette-result-title">${this.escapeHtml(result.title)}</div>
                                <div class="command-palette-result-url">${this.escapeHtml(result.url)}</div>
                            </div>
                            <div class="command-palette-result-action">${result.action} →</div>
                        `;
                        
                        item.addEventListener('click', () => {
                            if (result.type === 'tab') {
                                this.switchToTab(result.data.id);
                                this.hideCommandPalette();
                            } else if (result.type === 'search') {
                                this.executeCommandPaletteAction();
                            }
                        });
                        
                        this.commandPaletteResults.appendChild(item);
                    });
                }
            }

            selectNextResult() {
                const items = this.commandPaletteResults.querySelectorAll('.command-palette-result-item');
                if (items.length === 0) return;
                
                this.selectedResultIndex = (this.selectedResultIndex + 1) % items.length;
                items.forEach((item, index) => {
                    item.classList.toggle('selected', index === this.selectedResultIndex);
                });
            }

            selectPreviousResult() {
                const items = this.commandPaletteResults.querySelectorAll('.command-palette-result-item');
                if (items.length === 0) return;
                
                this.selectedResultIndex = this.selectedResultIndex <= 0 
                    ? items.length - 1 
                    : this.selectedResultIndex - 1;
                items.forEach((item, index) => {
                    item.classList.toggle('selected', index === this.selectedResultIndex);
                });
            }

            async executeCommandPaletteAction() {
                const value = this.commandPaletteInput.value.trim();
                
                if (this.commandPaletteMode === 'search') {
                    // Search mode: create new tab with search or URL
                    if (!value) {
                        this.hideCommandPalette();
                        return;
                    }
                    
                    let targetUrl = value;
                    if (!/^https?:\/\//i.test(value)) {
                        targetUrl = value.includes('.') && !value.includes(' ')
                            ? 'https://' + value
                            : 'https://www.google.com/search?q=' + encodeURIComponent(value);
                    }
                    
                    this.hideCommandPalette();
                    await this.createTab(targetUrl);
                } else {
                    // Ask mode: navigate to newtab.html with ask mode and optional query
                    this.hideCommandPalette();
                    const queryParam = value ? `&query=${encodeURIComponent(value)}` : '';
                    await this.createTab(`newtab.html?mode=ask${queryParam}`);
                }
            }

            createInitialTab() {
                console.log('createInitialTab called');
                this.createTab('https://www.google.com');
            }

            switchToTab(tabId) {
                // Hide all webviews and deactivate tabs
                this.tabs.forEach(tab => {
                    tab.webview.style.display = 'none';
                    tab.tabElement.classList.remove('active');
                    tab.tabElement.setAttribute('aria-selected', 'false');
                    if (tab.railElement) {
                        tab.railElement.classList.remove('active');
                        tab.railElement.setAttribute('aria-selected', 'false');
                    }
                });

                // Show selected webview and activate tab
                const tab = this.tabs.find(t => t.id === tabId);
                if (tab) {
                    tab.webview.style.display = 'flex';
                    tab.tabElement.classList.add('active');
                    tab.tabElement.setAttribute('aria-selected', 'true');
                    if (tab.railElement) {
                        tab.railElement.classList.add('active');
                        tab.railElement.setAttribute('aria-selected', 'true');
                    }
                    this.activeTabId = tabId;
                    this.urlBar.value = this.getDisplayUrl(tab.url);
                    this.updateNavBarVisibility(tab.url);

                    // Always show chat and summarize buttons
                    if (this.chatBtn) {
                        this.chatBtn.style.display = 'flex';
                    }
                    if (this.summarizeBtn) {
                        this.summarizeBtn.style.display = 'flex';
                    }

                    // Restore chat sidebar state for this tab
                    if (tab.chatSidebarOpen) {
                        this.showChatSidebar();
                    } else {
                        this.hideChatSidebar();
                    }
                    
                    this.updateChatContextUI(tab);
                    // Focus management
                    if (!this.urlBarContainer || this.urlBarContainer.style.display !== 'none') {
                        this.urlBar.focus();
                    } else if (tab.webview) {
                        tab.webview.focus();
                    }
                }
            }

            closeTab(tabId) {
                const tabIndex = this.tabs.findIndex(t => t.id === tabId);
                if (tabIndex === -1) return;

                const tab = this.tabs[tabIndex];
                
                // Remove from DOM
                tab.tabElement.remove();
                tab.webview.remove();
                if (tab.railElement) tab.railElement.remove();
                
                // Remove from tabs array
                this.tabs.splice(tabIndex, 1);

                // If this was the active tab, switch to another
                if (this.activeTabId === tabId) {
                    if (this.tabs.length > 0) {
                        const newActiveTab = this.tabs[Math.max(0, tabIndex - 1)];
                        this.switchToTab(newActiveTab.id);
                    } else {
                        // No tabs left, create a new one
                        this.createTab();
                    }
                }
            }

            closeActiveTab() {
                if (this.activeTabId) {
                    this.closeTab(this.activeTabId);
                }
            }

            async navigateToUrl() {
                const url = this.urlBar.value.trim();
                if (!url) return;

                const result = await window.electronAPI.navigateTo(url);
                if (result.success && this.activeTabId) {
                    const tab = this.tabs.find(t => t.id === this.activeTabId);
                    if (tab) {
                        tab.webview.loadURL(result.url);
                        tab.url = result.url;
                    }
                }
            }

            navigateBack() {
                if (this.activeTabId) {
                    const tab = this.tabs.find(t => t.id === this.activeTabId);
                    if (tab && tab.webview.canGoBack()) {
                        tab.webview.goBack();
                    }
                }
            }

            navigateForward() {
                if (this.activeTabId) {
                    const tab = this.tabs.find(t => t.id === this.activeTabId);
                    if (tab && tab.webview.canGoForward()) {
                        tab.webview.goForward();
                    }
                }
            }

            refreshPage() {
                if (this.activeTabId) {
                    const tab = this.tabs.find(t => t.id === this.activeTabId);
                    if (tab) {
                        tab.webview.reload();
                    }
                }
            }

            async handleChatSend() {
                if (!this.chatInput) return;
                const message = this.chatInput.value.trim();
                if (!message) return;
                this.chatInput.value = '';
            
                const tabId = this.activeTabId;
                const session = this.chatSessions.get(tabId) || [];
            
                // Add user message to session and UI
                session.push({ role: 'user', content: message });
                this.renderChatHistory(); // Re-render to show user message
            
                // Get context from all referenced tabs
                const activeTab = this.tabs.find(t => t.id === this.activeTabId);
                const contexts = [];
                
                if (activeTab) {
                    for (const tabId of activeTab.referencedTabs) {
                        const referencedTab = this.tabs.find(t => t.id === tabId);
                        if (referencedTab) {
                            try {
                                const context = await this.getPageContext(referencedTab);
                                if (context) contexts.push(context);
                            } catch (err) {
                                console.error(`Failed to get page context for referenced tab ${tabId}:`, err);
                            }
                        }
                    }
                }

                // Add placeholder for assistant message to session
                const assistantMessage = { role: 'assistant', content: '' };
                session.push(assistantMessage);
                const assistantMessageIndex = session.length - 1;
            
                // Re-render to show assistant placeholder
                this.renderChatHistory();
                this.chatHistory.scrollTop = this.chatHistory.scrollHeight;
            
                // Generate unique request ID and send to main process
                const reqId = Date.now().toString();
                window.electronAPI.sendChat(reqId, session.slice(0, -1), contexts); // Send all contexts
            
                const streamHandler = (data) => {
                    if (data.id !== reqId) return;
            
                    if (data.token) {
                        // Always update the session state in the background
                        assistantMessage.content += data.token;
            
                        // Only update the DOM if the message's tab is active
                        if (this.activeTabId === tabId) {
                            const msgContainer = document.getElementById(`asst-msg-${tabId}-${assistantMessageIndex}`);
                            if (msgContainer) {
                                const contentEl = msgContainer.querySelector('.chat-content');
                                // Update with raw text during stream for performance
                                contentEl.textContent = assistantMessage.content;
                                this.chatHistory.scrollTop = this.chatHistory.scrollHeight;
                            }
                        }
                    } else if (data.done) {
                        // Final state is already in assistantMessage.content
                        // Re-render one last time with markdown if the tab is active
                        if (this.activeTabId === tabId) {
                            const msgContainer = document.getElementById(`asst-msg-${tabId}-${assistantMessageIndex}`);
                            if (msgContainer) {
                                const contentEl = msgContainer.querySelector('.chat-content');
                                contentEl.innerHTML = this.marked.parse(assistantMessage.content);
                            }
                        }
                        // Save chat session after completion
                        this.saveChatSession(tabId);
                        window.electronAPI.removeListener('chat-stream', streamHandler);
                    } else if (data.error) {
                        assistantMessage.content = `Error: ${data.error}`;
                        if (this.activeTabId === tabId) {
                            this.renderChatHistory(); // Re-render to show the error
                        }
                        window.electronAPI.removeListener('chat-stream', streamHandler);
                    }
                };
            
                window.electronAPI.onChatStream(streamHandler);
            }

            async handleSummarizePage() {
                const tabId = this.activeTabId;
                const activeTab = this.tabs.find(t => t.id === tabId);
                if (!activeTab) {
                    return;
                }

                this.showChatSidebar();

                const session = this.chatSessions.get(tabId) || [];
                session.push({ role: 'user', content: 'Summarize this page.' });

                const assistantMessage = { role: 'assistant', content: '' };
                session.push(assistantMessage);
                const assistantMessageIndex = session.length - 1;

                this.renderChatHistory();
                this.chatHistory.scrollTop = this.chatHistory.scrollHeight;

                const contexts = [];
                try {
                    const context = await this.getPageContext(activeTab);
                    if (context) contexts.push(context);
                } catch (err) {
                    console.error('Failed to get page context for summarization:', err);
                }

                const reqId = Date.now().toString();
                window.electronAPI.sendChat(reqId, session.slice(0, -1), contexts);

                const streamHandler = (data) => {
                    if (data.id !== reqId) return;

                    if (data.token) {
                        assistantMessage.content += data.token;
                        if (this.activeTabId === tabId) {
                            const msgContainer = document.getElementById(`asst-msg-${tabId}-${assistantMessageIndex}`);
                            if (msgContainer) {
                                const contentEl = msgContainer.querySelector('.chat-content');
                                contentEl.textContent = assistantMessage.content;
                                this.chatHistory.scrollTop = this.chatHistory.scrollHeight;
                            }
                        }
                    } else if (data.done) {
                        if (this.activeTabId === tabId) {
                            const msgContainer = document.getElementById(`asst-msg-${tabId}-${assistantMessageIndex}`);
                            if (msgContainer) {
                                const contentEl = msgContainer.querySelector('.chat-content');
                                contentEl.innerHTML = this.marked.parse(assistantMessage.content);
                            }
                        }
                        // Save chat session after completion
                        this.saveChatSession(tabId);
                        window.electronAPI.removeListener('chat-stream', streamHandler);
                    } else if (data.error) {
                        assistantMessage.content = `Error: ${data.error}`;
                        if (this.activeTabId === tabId) {
                            this.renderChatHistory();
                        }
                        window.electronAPI.removeListener('chat-stream', streamHandler);
                    }
                };

                window.electronAPI.onChatStream(streamHandler);
            }

            async getPageContext(tab) {
                if (!tab || !tab.webview || tab.isLoading || tab.webview.isCrashed()) {
                    return null;
                }
                const webview = tab.webview;

                try {
                    const pageUrl = webview.getURL();
                    if (!pageUrl.startsWith('http')) {
                        return null;
                    }
                    const pageTitle = webview.getTitle();
                    const pageContent = await webview.executeJavaScript('document.body.innerText');
                    return {
                        title: pageTitle,
                        url: pageUrl,
                        content: pageContent.substring(0, 4000) // Truncate for performance
                    };
                } catch (e) {
                    console.error(`Could not get page context: `, e);
                    return null;
                }
            }


            toggleChatSidebar() {
                if (!this.chatSidebar) return;
                const currentTab = this.tabs.find(t => t.id === this.activeTabId);
                const isOpen = this.chatSidebar.classList.toggle('open');
                if (currentTab) {
                    currentTab.chatSidebarOpen = isOpen;
                }

                if (isOpen) {
                    this.showChatSidebar();
                } else {
                    this.hideChatSidebar();
                }
            }

            showChatSidebar() {
                if (!this.chatSidebar) return;
                const currentTab = this.tabs.find(t => t.id === this.activeTabId);
                if (!currentTab) return;

                // Auto-add current page as context if not already added
                if (!currentTab.referencedTabs.has(currentTab.id)) {
                    currentTab.referencedTabs.add(currentTab.id);
                }
                
                this.chatSidebar.classList.add('open');
                this.updateContentAreaWidth();
                this.chatInput.focus();
                this.renderChatHistory();
                this.updateChatContextUI(currentTab);
                currentTab.chatSidebarOpen = true;
            }

            hideChatSidebar(clearHistory = false) {
                if (!this.chatSidebar) return;
                this.chatSidebar.classList.remove('open');
                this.updateContentAreaWidth();

                const currentTab = this.tabs.find(t => t.id === this.activeTabId);
                if (currentTab) {
                    currentTab.chatSidebarOpen = false;
                }
                if (clearHistory) {
                    this.chatHistory.innerHTML = '';
                }
            }

            updateChatContextUI(tab) {
                this.renderContextPills();
                const hasContext = tab && tab.referencedTabs.size > 0;
                this.chatInput.placeholder = hasContext ? 'Ask a question about the page(s)...' : 'Ask AI...';
            }

            dismissPageContext() {
                // This function is no longer needed as individual pills are dismissed.
            }

            renderChatHistory() {
                if (!this.chatHistory) return;
                this.chatHistory.innerHTML = '';
                const messages = this.chatSessions.get(this.activeTabId) || [];
                messages.forEach((msg, index) => {
                    const wrapper = document.createElement('div');
                    wrapper.className = `chat-msg ${msg.role === 'user' ? 'user-msg' : 'assistant-msg'}`;
                    // Add a unique ID to the assistant message wrapper for easy targeting
                    if (msg.role === 'assistant') {
                        wrapper.id = `asst-msg-${this.activeTabId}-${index}`;
                    }
                    const label = document.createElement('div');
                    label.className = 'chat-label';
                    label.textContent = msg.role === 'user' ? 'You' : 'AI';
                    const content = document.createElement('div');
                    content.className = 'chat-content';
                    if (msg.role === 'assistant') {
                        content.innerHTML = this.marked.parse(msg.content);
                    } else {
                        content.textContent = msg.content;
                    }
                    wrapper.appendChild(label);
                    wrapper.appendChild(content);
                    this.chatHistory.appendChild(wrapper);
                });
                this.chatHistory.scrollTop = this.chatHistory.scrollHeight;
            }

            clearChat() {
                this.chatSessions.set(this.activeTabId, []);
                if (this.chatHistory) {
                    this.chatHistory.innerHTML = '';
                }
                // Also reset the context dismissal state
                const tab = this.tabs.find(t => t.id === this.activeTabId);
                if (tab) {
                    tab.referencedTabs.clear();
                    // Re-add current tab as context
                    tab.referencedTabs.add(tab.id);
                    this.updateChatContextUI(tab);
                }
                // Save empty session to clear stored chat
                this.saveChatSession(this.activeTabId);
            }

            handleChatInput() {
                const value = this.chatInput.value;
                const atIndex = value.lastIndexOf('@');

                if (atIndex > -1 && (atIndex === 0 || /\s/.test(value[atIndex - 1]))) {
                    const query = value.substring(atIndex + 1);
                    this.showTabSuggestions(query);
                } else {
                    this.hideTabSuggestions();
                }
            }

            handleSuggestionClick(e) {
                const item = e.target.closest('.suggestion-item');
                if (!item) return;

                const tabId = item.getAttribute('data-tab-id');
                const activeTab = this.tabs.find(t => t.id === this.activeTabId);

                if (tabId && activeTab) {
                    activeTab.referencedTabs.add(tabId);
                    this.updateChatContextUI(activeTab);

                    const atIndex = this.chatInput.value.lastIndexOf('@');
                    this.chatInput.value = this.chatInput.value.substring(0, atIndex);
                    this.hideTabSuggestions();
                    this.chatInput.focus();
                }
            }

            showTabSuggestions(query) {
                const activeTab = this.tabs.find(t => t.id === this.activeTabId);
                const filteredTabs = this.tabs.filter(tab =>
                    !activeTab.referencedTabs.has(tab.id) &&
                    (tab.title.toLowerCase().includes(query.toLowerCase()) ||
                     tab.url.toLowerCase().includes(query.toLowerCase()))
                );

                if (filteredTabs.length > 0) {
                    this.tabSuggestions.innerHTML = filteredTabs.map(tab => `
                        <div class="suggestion-item" data-tab-id="${tab.id}">
                            <div class="suggestion-title">${this.escapeHtml(tab.title)}</div>
                            <div class="suggestion-url">${this.escapeHtml(tab.url)}</div>
                        </div>
                    `).join('');
                    this.tabSuggestions.style.display = 'block';
                } else {
                    this.hideTabSuggestions();
                }
            }

            hideTabSuggestions() {
                this.tabSuggestions.style.display = 'none';
                this.tabSuggestions.innerHTML = '';
            }

            escapeHtml(str) {
                return str.replace(/[&<>"']/g, (match) => {
                    return {
                        '&': '&amp;',
                        '<': '&lt;',
                        '>': '&gt;',
                        '"': '&quot;',
                        "'": '&#39;'
                    }[match];
                });
            }

            handleSuggestionKeyboardNav(e) {
                // Future implementation for arrow key navigation
            }

            renderContextPills() {
                this.contextPillsContainer.innerHTML = '';
                const activeTab = this.tabs.find(t => t.id === this.activeTabId);
                if (!activeTab) return;

                for (const tabId of activeTab.referencedTabs) {
                    const tab = this.tabs.find(t => t.id === tabId);
                    if (tab) {
                        const pill = document.createElement('div');
                        pill.className = 'context-pill';
                        pill.innerHTML = `
                            <span class="context-pill-title" title="${this.escapeHtml(tab.title)}">${this.escapeHtml(tab.title)}</span>
                            <button class="context-pill-remove" data-tab-id="${tab.id}">&times;</button>
                        `;
                        this.contextPillsContainer.appendChild(pill);
                    }
                }

                // Add event listeners to remove buttons
                this.contextPillsContainer.querySelectorAll('.context-pill-remove').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        const tabIdToRemove = e.currentTarget.getAttribute('data-tab-id');
                        activeTab.referencedTabs.delete(tabIdToRemove);
                        this.updateChatContextUI(activeTab);
                    });
                });
            }

            async showHistory() {
                // Create or switch to history tab
                const historyUrl = 'history.html';
                const existingTab = this.tabs.find(t => t.url && t.url.includes('history.html'));
                
                if (existingTab) {
                    this.switchToTab(existingTab.id);
                } else {
                    await this.createTab(historyUrl);
                }
            }

            async saveHistoryEntry(url, title, favicon) {
                try {
                    // Don't save history in incognito mode
                    if (this.isIncognito) {
                        return;
                    }
                    // Skip internal pages
                    if (url.includes('history.html') || url.includes('newtab.html')) {
                        return;
                    }
                    await window.electronAPI.addHistory(url, title, favicon);
                } catch (error) {
                    console.error('Error saving history:', error);
                }
            }

            async saveChatSession(tabId) {
                try {
                    // Don't save chat sessions in incognito mode
                    if (this.isIncognito) {
                        return;
                    }
                    const session = this.chatSessions.get(tabId);
                    if (session && session.length > 0) {
                        await window.electronAPI.saveChat(tabId, session);
                    }
                } catch (error) {
                    console.error('Error saving chat session:', error);
                }
            }
        }

        // Initialize the browser when the page loads
        document.addEventListener('DOMContentLoaded', () => {
            try {
                new BrowserManager();
            } catch (error) {
                console.error('Error initializing BrowserManager:', error);
            }
        });
    </script>
</body>
</html>
