<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="AI Browser - Modern web browser with intelligent features">
    <title>AI Browser</title>
    <link rel="stylesheet" href="index.css">
    <!-- Markdown parser -->
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
</head>
<body>
    <div class="browser-container" role="application" aria-label="AI Browser">
        <!-- Hover trigger zone for collapsed sidebar -->
        <div class="hover-trigger-zone" id="hoverTriggerZone"></div>
        <!-- Left Tab Rail -->
        <aside class="tab-rail" aria-label="Tab Sidebar">
            <div class="tab-rail-header">
            </div>
            <div class="rail-url">
                <div class="rail-url-controls">
                    <button class="nav-btn" id="backBtn" title="Go back (⌘←)" aria-label="Navigate back">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M19 12H5" />
                            <path d="M12 5l-7 7 7 7" />
                        </svg>
                    </button>
                    <button class="nav-btn" id="forwardBtn" title="Go forward (⌘→)" aria-label="Navigate forward">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M5 12h14" />
                            <path d="M12 5l7 7-7 7" />
                        </svg>
                    </button>
                    <button class="nav-btn" id="refreshBtn" title="Refresh page (⌘R)" aria-label="Refresh current page">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <polyline points="23 4 23 10 17 10" />
                            <polyline points="1 20 1 14 7 14" />
                            <path d="M3.51 9a9 9 0 0114.13-3.36L23 10" />
                            <path d="M20.49 15a9 9 0 01-14.13 3.36L1 14" />
                        </svg>
                    </button>
                </div>
                <div class="url-input-wrapper">
                    <input type="url" 
                           class="url-bar" 
                           id="urlBar" 
                           placeholder="Search or enter website URL..."
                           aria-label="Address bar"
                           autocomplete="url"
                           spellcheck="false">
                    <div class="url-suggestions" id="urlSuggestions" role="listbox" aria-label="URL suggestions"></div>
                </div>
                <div class="rail-url-actions">
                    <button class="go-btn" id="goBtn" title="Go" aria-label="Go">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <line x1="6" y1="12" x2="18" y2="12" />
                            <polyline points="13 7 18 12 13 17" />
                        </svg>
                    </button>
                    <button class="chat-btn" id="chatBtn" title="AI Chat (⌘E)" aria-label="Open AI Chat">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M21 15a2 2 0 01-2 2H7l-4 4V5a2 2 0 012-2h14a2 2 0 012 2z" />
                        </svg>
                    </button>
                    <button class="summarize-btn" id="summarizeBtn" title="Summarize Page" aria-label="Summarize current page">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <line x1="21" y1="6" x2="8" y2="6" />
                            <line x1="21" y1="12" x2="8" y2="12" />
                            <line x1="21" y1="18" x2="8" y2="18" />
                            <line x1="3" y1="6" x2="3" y2="6" />
                            <line x1="3" y1="12" x2="3" y2="12" />
                            <line x1="3" y1="18" x2="3" y2="18" />
                        </svg>
                    </button>
                </div>
            </div>
            <button class="rail-new-tab-pill" id="railNewTabBtn" title="New Tab (⌘T)" aria-label="Open new tab">
                <span class="plus">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M12 4v16M20 12H4" />
                    </svg>
                </span>
                <span style="font-weight:600;">New Tab</span>
            </button>
            <div class="tab-rail-tabs" id="tabRailTabs" role="listbox" aria-label="Open Tabs"></div>
            <div class="sidebar-resizer tab-rail-resizer" id="tabRailResizer" role="separator" aria-orientation="vertical" aria-label="Resize tab sidebar" tabindex="0"></div>
        </aside>
        <!-- Hidden top tab bar kept only as logical container for existing code -->
        <div class="tab-bar" role="tablist" aria-label="Browser tabs" style="display:none">
            <div class="tabs-container" id="tabsContainer"></div>
        </div>

        <!-- AI Chat Sidebar -->
        <aside class="chat-sidebar" id="chatSidebar" role="complementary" aria-label="AI Chat Sidebar">
            <div class="sidebar-resizer chat-sidebar-resizer" id="chatSidebarResizer" role="separator" aria-orientation="vertical" aria-label="Resize AI chat sidebar" tabindex="0"></div>
            <div class="chat-history" id="chatHistory" tabindex="0" aria-live="polite" aria-atomic="false"></div>
            <div class="chat-input-area">
                <div id="contextPillsContainer" class="context-pills-container"></div>
                <form class="chat-input-container" id="chatInputForm" autocomplete="off">
                    <button type="button" class="chat-clear-btn" id="chatClearBtn" aria-label="Clear chat" title="Clear chat">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M3 6h18" />
                            <path d="M8 6v12a2 2 0 002 2h4a2 2 0 002-2V6" />
                            <line x1="10" y1="11" x2="14" y2="11" />
                            <line x1="10" y1="15" x2="14" y2="15" />
                        </svg>
                    </button>
                    <div class="chat-input-wrapper">
                        <input id="chatInput" class="chat-input" type="text" placeholder="Ask AI..." aria-label="Chat input" />
                        <div id="tabSuggestions" class="tab-suggestions"></div>
                    </div>
                    <button type="submit" class="chat-send-btn" id="chatSendBtn" aria-label="Send message">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <line x1="22" y1="2" x2="11" y2="13" />
                            <polygon points="22 2 15 22 11 13 2 9 22 2" />
                        </svg>
                    </button>
                </form>
            </div>
        </aside>

        <!-- Web Content Area -->
        <main class="content-area" id="contentArea" role="main" aria-label="Web content">
            <!-- Loading state -->
            <div class="loading-state" id="loadingState" style="display: none;">
                <div class="loading-indicator">
                    <div class="loading-spinner" aria-hidden="true"></div>
                    <span>Loading page...</span>
                </div>
            </div>
            
            <!-- Error state -->
            <div class="error-state" id="errorState" style="display: none;">
                <div class="error-page">
                    <svg width="48" height="48" viewBox="0 0 24 24" fill="var(--color-text-tertiary)" aria-hidden="true">
                        <path d="M12 9v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"/>
                    </svg>
                    <h2>Unable to load page</h2>
                    <p>Please check your internet connection and try again.</p>
                    <button class="retry-btn" id="retryBtn">Try Again</button>
                </div>
            </div>
            
            <!-- Web views will be dynamically added here -->
        </main>
    </div>

    <script>
        class BrowserManager {
            constructor() {
                this.tabs = [];
                this.activeTabId = null;
                this.tabCounter = 0;
                this.sidebarConstraints = {
                    tabRail: { min: 200, max: 420, default: 260 },
                    chatSidebar: { min: 260, max: 560, default: 320 }
                };
                this.activeResize = null;
                this.rootStyle = document.documentElement.style;
                this.handleSidebarResize = this.handleSidebarResize.bind(this);
                this.stopSidebarResize = this.stopSidebarResize.bind(this);
                this.sidebarCollapsed = false;
                this.sidebarHoveredWhileCollapsed = false;
                
                this.initializeElements();
                this.setupResizableSidebars();
                this.setupEventListeners();
                this.createInitialTab();
                this.setupKeyboardShortcuts();
                this.chatSessions = new Map();
                this.marked = window.marked;
            }

            initializeElements() {
                this.tabsContainer = document.getElementById('tabsContainer');
                this.newTabBtn = document.getElementById('railNewTabBtn');
                this.tabRailTabs = document.getElementById('tabRailTabs');
                this.railNewTabBtn = document.getElementById('railNewTabBtn');
                this.backBtn = document.getElementById('backBtn');
                this.forwardBtn = document.getElementById('forwardBtn');
                this.refreshBtn = document.getElementById('refreshBtn');
                this.urlBar = document.getElementById('urlBar');
                this.goBtn = document.getElementById('goBtn');
                this.contentArea = document.getElementById('contentArea');
                this.loadingState = document.getElementById('loadingState');
                this.errorState = document.getElementById('errorState');
                this.retryBtn = document.getElementById('retryBtn');
                // References for showing/hiding the URL bar portion on the new-tab page
                this.navBar = document.querySelector('.nav-bar');
                this.urlBarContainer = document.querySelector('.url-bar-container');
                this.chatBtn = document.getElementById('chatBtn');
                this.summarizeBtn = document.getElementById('summarizeBtn');
                this.chatSidebar = document.getElementById('chatSidebar');
                this.chatInput = document.getElementById('chatInput');
                this.chatInputForm = document.getElementById('chatInputForm');
                this.chatHistory = document.getElementById('chatHistory');
                this.chatClearBtn = document.getElementById('chatClearBtn');
                this.contextPillsContainer = document.getElementById('contextPillsContainer');
                this.tabSuggestions = document.getElementById('tabSuggestions');
                this.tabRailResizer = document.getElementById('tabRailResizer');
                this.chatSidebarResizer = document.getElementById('chatSidebarResizer');
                this.tabRail = document.querySelector('.tab-rail');
                this.hoverTriggerZone = document.getElementById('hoverTriggerZone');

                // Listen for messages from webviews
                window.addEventListener('message', (e) => {
                    console.log('BrowserManager received message:', e.data);
                    console.log('BrowserManager received message from source:', e.source);
                    if (!e.data || !e.data.type) return;

                    // Handle shortcut messages from newtab.html
                    if (e.data.type === 'shortcut') {
                        switch (e.data.command) {
                            case 'close-tab':
                                this.closeActiveTab();
                                break;
                            case 'new-tab':
                                this.createTab();
                                break;
                            case 'focus-url':
                                if (!this.urlBarContainer || this.urlBarContainer.style.display !== 'none') {
                                    this.urlBar.focus();
                                }
                                break;
                        }
                    }

                    // Handle tab context requests from newtab.html
                    if (e.data.type === 'request-tabs') {
                        // Try to find sender by contentWindow; if not found, fall back to active newtab
                        let sourceWebview = this.tabs.find(tab => tab.webview && tab.webview.contentWindow === e.source);
                        if (!sourceWebview) {
                            sourceWebview = this.tabs.find(tab => tab.id === this.activeTabId && tab.url && tab.url.includes('newtab.html'));
                        }
                        if (sourceWebview) {
                            const tabData = this.tabs
                                .filter(t => t.id !== sourceWebview.id && !t.url.includes('newtab.html'))
                                .map(t => ({ id: t.id, title: t.title, url: t.url }));

                        try {
                            // Send message to guest via IPC channel bridged by preload
                            sourceWebview.webview.send('guest-message', { type: 'tabs-response', tabs: tabData });
                        } catch (err) {
                            console.error('Failed to send tabs response:', err);
                        }
                        }
                    }

                    // Handle chat requests from newtab.html
                    if (e.data.type === 'new-tab-chat-send') {
                        console.log('Received new-tab-chat-send message:', e.data);
                        console.log('Handling new-tab-chat-send with data:', e.data);
                        // Find the source webview by checking if it contains newtab.html
                        const sourceWebview = this.tabs.find(tab => 
                            tab.url && tab.url.includes('newtab.html') && tab.id === this.activeTabId
                        );
                        if (sourceWebview) {
                            console.log('Found source webview, calling handleNewTabChat');
                            console.log('Source webview found:', sourceWebview.id);
                            this.handleNewTabChat(e.data, sourceWebview);
                        } else {
                            console.error('Could not find source webview for chat request');
                        }
                    }
                });
            }

            setupResizableSidebars() {
                if (!this.rootStyle) {
                    this.rootStyle = document.documentElement.style;
                }

                const savedTabRailWidth = this.getStoredSidebarWidth('tabRailWidth');
                if (savedTabRailWidth !== null) {
                    this.setTabRailWidth(savedTabRailWidth, false);
                }

                const savedChatSidebarWidth = this.getStoredSidebarWidth('chatSidebarWidth');
                if (savedChatSidebarWidth !== null) {
                    this.setChatSidebarWidth(savedChatSidebarWidth, false);
                }

                // Restore collapsed state from localStorage
                const savedCollapsedState = localStorage.getItem('sidebarCollapsed');
                if (savedCollapsedState === 'true') {
                    this.sidebarCollapsed = true;
                    this.tabRail.classList.add('collapsed');
                    this.hoverTriggerZone.classList.add('active');
                }

                if (this.tabRailResizer) {
                    this.tabRailResizer.addEventListener('pointerdown', (event) => this.startSidebarResize('tabRail', event));
                    this.tabRailResizer.addEventListener('keydown', (event) => this.handleResizerKeydown('tabRail', event));
                }

                if (this.chatSidebarResizer) {
                    this.chatSidebarResizer.addEventListener('pointerdown', (event) => this.startSidebarResize('chatSidebar', event));
                    this.chatSidebarResizer.addEventListener('keydown', (event) => this.handleResizerKeydown('chatSidebar', event));
                }

                // Setup hover behavior for collapsed sidebar
                if (this.hoverTriggerZone && this.tabRail) {
                    this.hoverTriggerZone.addEventListener('mouseenter', () => {
                        if (this.sidebarCollapsed) {
                            this.sidebarHoveredWhileCollapsed = true;
                            this.tabRail.classList.remove('collapsed');
                        }
                    });

                    this.tabRail.addEventListener('mouseleave', () => {
                        if (this.sidebarCollapsed && this.sidebarHoveredWhileCollapsed) {
                            this.sidebarHoveredWhileCollapsed = false;
                            this.tabRail.classList.add('collapsed');
                        }
                    });
                }

                this.updateContentAreaWidth();
            }

            getStoredSidebarWidth(key) {
                try {
                    const stored = localStorage.getItem(key);
                    if (stored) {
                        const parsed = parseInt(stored, 10);
                        if (!Number.isNaN(parsed)) {
                            return parsed;
                        }
                    }
                } catch (error) {
                    console.warn('Failed to read stored sidebar width:', error);
                }
                return null;
            }

            startSidebarResize(sidebar, event) {
                if (event.button !== undefined && event.button !== 0) return;
                event.preventDefault();
                const clientX = event.clientX;
                if (typeof clientX !== 'number') return;

                const initialWidth = this.getCurrentSidebarWidth(sidebar);
                this.activeResize = {
                    sidebar,
                    startX: clientX,
                    initialWidth,
                    lastWidth: initialWidth,
                    handleElement: event.currentTarget
                };

                if (this.activeResize.handleElement) {
                    this.activeResize.handleElement.classList.add('dragging');
                    if (event.pointerId != null && this.activeResize.handleElement.setPointerCapture) {
                        try {
                            this.activeResize.handleElement.setPointerCapture(event.pointerId);
                        } catch (_) {}
                    }
                }

                document.addEventListener('pointermove', this.handleSidebarResize);
                document.addEventListener('pointerup', this.stopSidebarResize);
                document.addEventListener('pointercancel', this.stopSidebarResize);
            }

            handleSidebarResize(event) {
                if (!this.activeResize) return;
                event.preventDefault();
                const clientX = event.clientX;
                if (typeof clientX !== 'number') return;

                let newWidth = this.activeResize.initialWidth;
                if (this.activeResize.sidebar === 'tabRail') {
                    newWidth = this.clampWidth(
                        this.activeResize.initialWidth + (clientX - this.activeResize.startX),
                        this.sidebarConstraints.tabRail.min,
                        this.sidebarConstraints.tabRail.max
                    );
                    this.setTabRailWidth(newWidth, false);
                } else {
                    newWidth = this.clampWidth(
                        this.activeResize.initialWidth + (this.activeResize.startX - clientX),
                        this.sidebarConstraints.chatSidebar.min,
                        this.sidebarConstraints.chatSidebar.max
                    );
                    this.setChatSidebarWidth(newWidth, false);
                }

                this.activeResize.lastWidth = newWidth;
            }

            stopSidebarResize(event) {
                if (!this.activeResize) return;
                const finalWidth = this.activeResize.lastWidth;

                if (typeof finalWidth === 'number') {
                    if (this.activeResize.sidebar === 'tabRail') {
                        this.setTabRailWidth(finalWidth);
                    } else {
                        this.setChatSidebarWidth(finalWidth);
                    }
                }

                if (this.activeResize.handleElement) {
                    this.activeResize.handleElement.classList.remove('dragging');
                    if (event && event.pointerId != null && this.activeResize.handleElement.releasePointerCapture) {
                        try {
                            this.activeResize.handleElement.releasePointerCapture(event.pointerId);
                        } catch (_) {}
                    }
                }

                this.activeResize = null;
                document.removeEventListener('pointermove', this.handleSidebarResize);
                document.removeEventListener('pointerup', this.stopSidebarResize);
                document.removeEventListener('pointercancel', this.stopSidebarResize);
            }

            handleResizerKeydown(sidebar, event) {
                if (event.key !== 'ArrowLeft' && event.key !== 'ArrowRight') return;
                const step = event.shiftKey ? 20 : 10;

                if (sidebar === 'tabRail') {
                    const delta = event.key === 'ArrowLeft' ? -step : step;
                    this.setTabRailWidth(this.getCurrentSidebarWidth('tabRail') + delta);
                } else {
                    const delta = event.key === 'ArrowLeft' ? step : -step;
                    this.setChatSidebarWidth(this.getCurrentSidebarWidth('chatSidebar') + delta);
                }

                event.preventDefault();
            }

            setTabRailWidth(width, persist = true) {
                const clamped = this.clampWidth(
                    width,
                    this.sidebarConstraints.tabRail.min,
                    this.sidebarConstraints.tabRail.max
                );

                if (this.rootStyle) {
                    this.rootStyle.setProperty('--tab-rail-width', `${clamped}px`);
                }

                if (persist) {
                    this.persistSidebarWidth('tabRailWidth', clamped);
                }

                this.updateContentAreaWidth();
                return clamped;
            }

            setChatSidebarWidth(width, persist = true) {
                const clamped = this.clampWidth(
                    width,
                    this.sidebarConstraints.chatSidebar.min,
                    this.sidebarConstraints.chatSidebar.max
                );

                if (this.rootStyle) {
                    this.rootStyle.setProperty('--chat-sidebar-width', `${clamped}px`);
                }

                if (persist) {
                    this.persistSidebarWidth('chatSidebarWidth', clamped);
                }

                this.updateContentAreaWidth();
                return clamped;
            }

            persistSidebarWidth(key, value) {
                try {
                    localStorage.setItem(key, String(value));
                } catch (error) {
                    console.warn('Failed to persist sidebar width:', error);
                }
            }

            getCurrentSidebarWidth(sidebar) {
                const varName = sidebar === 'tabRail' ? '--tab-rail-width' : '--chat-sidebar-width';
                const constraints = sidebar === 'tabRail' ? this.sidebarConstraints.tabRail : this.sidebarConstraints.chatSidebar;
                const computed = getComputedStyle(document.documentElement).getPropertyValue(varName);
                const parsed = parseInt(computed, 10);
                if (!Number.isNaN(parsed)) {
                    return parsed;
                }
                return constraints.default;
            }

            clampWidth(value, min, max) {
                return Math.min(Math.max(value, min), max);
            }

            updateContentAreaWidth() {
                if (!this.contentArea) return;
                const chatOpen = this.chatSidebar && this.chatSidebar.classList.contains('open');
                if (chatOpen) {
                    this.contentArea.style.width = `calc(100% - var(--tab-rail-width) - var(--chat-sidebar-width) - var(--spacing-1) - var(--spacing-1))`;
                } else {
                    this.contentArea.style.width = '';
                }
            }

            toggleSidebarCollapse() {
                this.sidebarCollapsed = !this.sidebarCollapsed;
                
                if (this.sidebarCollapsed) {
                    this.tabRail.classList.add('collapsed');
                    this.hoverTriggerZone.classList.add('active');
                } else {
                    this.tabRail.classList.remove('collapsed');
                    this.hoverTriggerZone.classList.remove('active');
                    this.sidebarHoveredWhileCollapsed = false;
                }
                
                // Persist state to localStorage
                localStorage.setItem('sidebarCollapsed', this.sidebarCollapsed.toString());
                
                this.updateContentAreaWidth();
            }

            async handleNewTabChat(data, sourceTab) {
                console.log('handleNewTabChat called with:', data);
                console.log('handleNewTabChat starting for reqId:', data.reqId);
                const { reqId, session, referencedTabIds } = data;
                const contexts = [];

                for (const tabId of referencedTabIds) {
                    const referencedTab = this.tabs.find(t => t.id === tabId);
                    if (referencedTab) {
                        try {
                            const context = await this.getPageContext(referencedTab);
                            if (context) {
                                console.log('Got context for tab:', tabId);
                                contexts.push(context);
                            }
                        } catch (err) {
                            console.error(`Failed to get page context for tab ${tabId}:`, err);
                        }
                    }
                }

                console.log('Sending chat request with contexts:', contexts.length);
                console.log('Sending to electronAPI.sendChat');
                const streamHandler = (streamData) => {
                    console.log('Received stream data:', streamData);
                    console.log('Stream handler called with:', streamData);
                    // Only handle responses for this request and forward to the source webview
                    if (streamData.id === reqId) {
                        // Forward streamed chat data to the webview
                        try {
                            const payload = { type: 'chat-stream-response', ...streamData };
                            console.log('Forwarding stream to webview via send(channel):', payload);
                            sourceTab.webview.send('guest-message', payload);
                        } catch (err) {
                            console.error('Failed to send message to webview via send:', err);
                        }
                        
                        if (streamData.done || streamData.error) {
                            // Clean up listener after completion or error
                            console.log('Stream done or error, removing listener');
                            window.electronAPI.removeListener('chat-stream', streamHandler);
                        }
                    }
                };

                // Ensure we don't have duplicate listeners; add before sending to avoid race
                console.log('Adding chat-stream listener');
                window.electronAPI.onChatStream(streamHandler);

                try {
                    // Fire and forget so we don't miss early tokens
                    window.electronAPI.sendChat(reqId, session, contexts);
                } catch (error) {
                    console.error('Error sending chat request:', error);
                    // Send error back to newtab immediately
                    try {
                        sourceTab.webview.send('guest-message', { type: 'chat-stream-response', id: reqId, error: error.message });
                    } catch (e2) {
                        console.error('Failed to send error to guest:', e2);
                    }
                }
            }

            setupEventListeners() {
                // Tab management
                this.newTabBtn.addEventListener('click', () => this.createTab());
                
                // Navigation
                this.backBtn.addEventListener('click', () => this.navigateBack());
                this.forwardBtn.addEventListener('click', () => this.navigateForward());
                this.refreshBtn.addEventListener('click', () => this.refreshPage());
                this.goBtn.addEventListener('click', () => this.navigateToUrl());
                this.retryBtn.addEventListener('click', () => this.refreshPage());
                
                // URL bar
                this.urlBar.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        this.navigateToUrl();
                    }
                });

                // URL bar text selection with improved UX
                this.urlBar.addEventListener('focus', () => {
                    this.urlBar.select();
                });

                // Enhanced click behavior
                this.urlBar.addEventListener('click', (e) => {
                    if (this.urlBar.selectionStart === this.urlBar.selectionEnd) {
                        this.urlBar.select();
                    }
                });

                // Chat button
                if (this.chatBtn) {
                    this.chatBtn.addEventListener('click', () => this.toggleChatSidebar());
                }

                // Summarize button
                if (this.summarizeBtn) {
                    this.summarizeBtn.addEventListener('click', () => this.handleSummarizePage());
                }

                // Chat form submission
                if (this.chatInputForm) {
                    this.chatInputForm.addEventListener('submit', (e) => {
                        e.preventDefault();
                        this.handleChatSend();
                    });
                }
                if (this.chatClearBtn) {
                    this.chatClearBtn.addEventListener('click', () => this.clearChat());
                }

                this.chatInput.addEventListener('input', () => this.handleChatInput());
                this.chatInput.addEventListener('keydown', (e) => this.handleSuggestionKeyboardNav(e));
                this.tabSuggestions.addEventListener('click', (e) => this.handleSuggestionClick(e));

                // Electron menu shortcuts
                // From menu/global accelerator
                window.electronAPI.onNewTab(async () => {
                    const tab = await this.createTab();
                    if (tab && tab.url && tab.url.includes('newtab.html')) {
                        this.ensureNewTabFocus(tab);
                    }
                });
                window.electronAPI.onCloseTab(() => this.closeActiveTab());
                window.electronAPI.onNavigateBack(() => this.navigateBack());
                window.electronAPI.onNavigateForward(() => this.navigateForward());
                window.electronAPI.onRefreshPage(() => this.refreshPage());
                // Global accelerators that must work when webview is focused
                window.electronAPI.onFocusUrl(() => {
                    if (!this.urlBarContainer || this.urlBarContainer.style.display !== 'none') {
                        this.urlBar.focus();
                    }
                });
                window.electronAPI.onToggleChat(() => this.toggleChatSidebar());
                window.electronAPI.onToggleSidebar(() => this.toggleSidebarCollapse());
                // Tab numeric selection from menu accelerators
                window.electronAPI.onSelectTab(({ index }) => this.selectTabByNumber(index));

                // Window resize handling
                window.addEventListener('resize', this.debounce(() => {
                    this.updateLayout();
                }, 250));
            }

            setupKeyboardShortcuts() {
                document.addEventListener('keydown', (e) => {
                    // Handle keyboard shortcuts
                    if (e.metaKey || e.ctrlKey) {
                        switch (e.key) {
                            case 't':
                                e.preventDefault();
                                this.createTab().then(tab => {
                                    if (tab && tab.url && tab.url.includes('newtab.html')) {
                                        this.ensureNewTabFocus(tab);
                                    }
                                });
                                break;
                            case 'w':
                                e.preventDefault();
                                this.closeActiveTab();
                                break;
                            case 'r':
                                e.preventDefault();
                                this.refreshPage();
                                break;
                            case 'l':
                                e.preventDefault();
                                this.urlBar.focus();
                                break;
                            case 'e':
                                e.preventDefault();
                                this.toggleChatSidebar();
                                break;
                            case 's':
                                e.preventDefault();
                                this.toggleSidebarCollapse();
                                break;
                            default: {
                                // Number keys 1-9 to switch tabs like Chrome
                                if (/^[1-9]$/.test(e.key)) {
                                    e.preventDefault();
                                    this.selectTabByNumber(parseInt(e.key, 10));
                                }
                                break;
                            }
                        }
                    }
                });
            }

            // Try repeatedly to focus and select the new-tab search input
            ensureNewTabFocus(tabOrId, attempts = 15) {
                try {
                    const tab = typeof tabOrId === 'string' ? this.tabs.find(t => t.id === tabOrId) : tabOrId;
                    if (!tab || !tab.webview) return;
                    // Only applicable for new tab page
                    if (!(tab.url && tab.url.includes('newtab.html'))) return;
                    tab.webview.focus();
                    const script = '(() => { const el = document.getElementById("searchInput"); if (el) { el.focus(); if (el.select) el.select(); return true; } return false; })()';
                    tab.webview.executeJavaScript(script).then(ok => {
                        if (!ok && attempts > 0) {
                            setTimeout(() => this.ensureNewTabFocus(tab.id, attempts - 1), 100);
                        }
                    }).catch(() => {
                        if (attempts > 0) {
                            setTimeout(() => this.ensureNewTabFocus(tab.id, attempts - 1), 100);
                        }
                    });
                } catch (_) { /* noop */ }
            }

            selectTabByNumber(n) {
                if (!this.tabs.length) return;
                // Chrome behavior: 1-8 go to that index; 9 goes to last tab
                let targetIndex = n === 9 ? this.tabs.length - 1 : n - 1;
                if (targetIndex < 0) targetIndex = 0;
                if (targetIndex >= this.tabs.length) return; // Ignore if beyond tab count (except 9 handled above)
                const targetTab = this.tabs[targetIndex];
                if (targetTab) this.switchToTab(targetTab.id);
            }

            debounce(func, wait) {
                let timeout;
                return function executedFunction(...args) {
                    const later = () => {
                        clearTimeout(timeout);
                        func(...args);
                    };
                    clearTimeout(timeout);
                    timeout = setTimeout(later, wait);
                };
            }

            updateLayout() {
                // Handle any layout updates needed on resize
                this.tabs.forEach(tab => {
                    if (tab.webview) {
                        // Webviews automatically handle resize
                    }
                });
            }

            // Show or hide the navigation bar depending on the active URL
            updateNavBarVisibility(url) {
                if (!this.urlBarContainer) return;
                // URL bar now lives in the sidebar and should stay visible
                this.urlBarContainer.style.display = 'flex';
            }

            async createTab(url = 'newtab.html') {
                const preloadPath = await window.electronAPI.getPreloadPath();
                console.log('createTab called with url:', url);
                const tabId = `tab-${++this.tabCounter}`;
                
                // Create tab object
                const tab = {
                    id: tabId,
                    url: url,
                    title: 'New Tab',
                    webview: null,
                    isLoading: false,
                    chatSidebarOpen: false, // Track chat sidebar state per tab
                    referencedTabs: new Set(), // Store IDs of all context tabs
                    railElement: null,
                    railTitle: null,
                    railFavicon: null,
                };

                // Create enhanced tab UI with better accessibility
                const tabElement = document.createElement('div');
                tabElement.className = 'tab';
                tabElement.setAttribute('data-tab-id', tabId);
                tabElement.setAttribute('role', 'tab');
                tabElement.setAttribute('aria-selected', 'false');
                tabElement.setAttribute('tabindex', '-1');
                
                const tabTitle = document.createElement('span');
                tabTitle.className = 'tab-title';
                tabTitle.textContent = 'New Tab';
                tabTitle.setAttribute('aria-label', 'Tab title');
                
                const tabFavicon = document.createElement('img');
                tabFavicon.className = 'tab-favicon';
                // Use empty src initially; will update once favicon arrives
                tabFavicon.alt = '';
                
                // Helper to set favicon through fallback when direct event missing
                const updateFaviconFallback = async () => {
                    try {
                        // Try to find <link rel="icon"> inside the page
                        const candidate = await webview.executeJavaScript(`(() => {
                            const relIcons = Array.from(document.querySelectorAll('link[rel~="icon"]'));
                            if (relIcons.length) return relIcons[0].href || null;
                            return null;
                        })()`, true);
                        let iconUrl = candidate;
                        if (iconUrl) {
                            // Resolve relative paths
                            if (iconUrl.startsWith('/')) {
                                try {
                                    iconUrl = new URL(iconUrl, webview.getURL()).href;
                                } catch (err) {}
                            }
                            tabFavicon.src = iconUrl;
                            if (tab.railFavicon) tab.railFavicon.src = iconUrl;
                        } else {
                            // Use Google favicon service as final fallback
                            try {
                                const pageOrigin = new URL(webview.getURL()).origin;
                                const fallback = `https://www.google.com/s2/favicons?sz=32&domain_url=${encodeURIComponent(pageOrigin)}`;
                                tabFavicon.src = fallback;
                                if (tab.railFavicon) tab.railFavicon.src = fallback;
                            } catch (err) {}
                        }
                    } catch (err) {
                        console.error('Failed to fetch favicon via fallback:', err);
                    }
                };

                const closeBtn = document.createElement('button');
                closeBtn.className = 'tab-close-btn';
                closeBtn.setAttribute('aria-label', 'Close tab');
                closeBtn.setAttribute('title', 'Close tab (⌘W)');
                closeBtn.innerHTML = `
                    <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <line x1="18" y1="6" x2="6" y2="18" />
                        <line x1="6" y1="6" x2="18" y2="18" />
                    </svg>
                `;
                closeBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    this.closeTab(tabId);
                });

                tabElement.appendChild(tabTitle);
                tabElement.appendChild(tabFavicon);
                // Ensure favicon appears before the title for better UX
                if (tabElement.contains(tabTitle)) {
                    tabElement.insertBefore(tabFavicon, tabTitle);
                }
                tabElement.appendChild(closeBtn);
                
                tabElement.addEventListener('click', () => this.switchToTab(tabId));
                tabElement.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter' || e.key === ' ') {
                        e.preventDefault();
                        this.switchToTab(tabId);
                    }
                });
                
                this.tabsContainer.appendChild(tabElement);

                // Create matching item in the left rail
                if (this.tabRailTabs) {
                    const railElement = document.createElement('div');
                    railElement.className = 'rail-tab';
                    railElement.setAttribute('data-tab-id', tabId);
                    railElement.setAttribute('role', 'option');
                    railElement.setAttribute('aria-selected', 'false');

                    const railFavicon = document.createElement('img');
                    railFavicon.className = 'rail-favicon';
                    railFavicon.alt = '';

                    const railTitle = document.createElement('span');
                    railTitle.className = 'rail-title';
                    railTitle.textContent = 'New Tab';

                    const railCloseBtn = document.createElement('button');
                    railCloseBtn.className = 'rail-close-btn';
                    railCloseBtn.setAttribute('aria-label', 'Close tab');
                    railCloseBtn.setAttribute('title', 'Close tab (⌘W)');
                    railCloseBtn.innerHTML = `
                        <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <line x1="18" y1="6" x2="6" y2="18" />
                            <line x1="6" y1="6" x2="18" y2="18" />
                        </svg>
                    `;
                    railCloseBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        this.closeTab(tabId);
                    });

                    railElement.appendChild(railFavicon);
                    railElement.appendChild(railTitle);
                    railElement.appendChild(railCloseBtn);

                    railElement.addEventListener('click', () => this.switchToTab(tabId));
                    railElement.addEventListener('keydown', (e) => {
                        if (e.key === 'Enter' || e.key === ' ') {
                            e.preventDefault();
                            this.switchToTab(tabId);
                        }
                    });

                    this.tabRailTabs.appendChild(railElement);

                    tab.railElement = railElement;
                    tab.railTitle = railTitle;
                    tab.railFavicon = railFavicon;
                }

                // Create webview with enhanced loading states
                const webview = document.createElement('webview');
                webview.style.display = 'none';
                // Note: removed webview.src = url;
                webview.setAttribute('allowpopups', '');
                webview.setAttribute('webpreferences', 'contextIsolation=true');
                webview.setAttribute('preload', `file://${preloadPath}`);
                webview.setAttribute('useragent', 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36 AI-Browser/1.0');
                webview.setAttribute('partition', 'persist:browser');
                const result = await window.electronAPI.navigateTo(url);
                console.log('navigateTo result:', result);
                if (result.success) {
                  tab.url = result.url;
                  webview.setAttribute('src', result.url); // Set src instead of loadURL
                } else {
                  console.error('Navigation failed:', result.error);
                }

                // Enhanced webview event handling
                webview.addEventListener('dom-ready', () => {
                    try {
                        tab.title = webview.getTitle() || 'New Tab';
                        tabTitle.textContent = tab.title;
                        tabTitle.setAttribute('title', tab.title);
                        if (tab.railTitle) {
                            tab.railTitle.textContent = tab.title;
                            tab.railTitle.setAttribute('title', tab.title);
                        }
                        if (this.activeTabId === tabId) {
                            this.urlBar.value = webview.getURL();
                            this.hideLoading();
                            if (webview.getURL().includes('newtab.html')) {
                                webview.focus();
                                // Delay to ensure newtab is fully loaded, then focus + select search input
                                setTimeout(() => {
                                    const script = '(() => { const el = document.getElementById("searchInput"); if (el) { el.focus(); if (el.select) el.select(); } })()';
                                    webview.executeJavaScript(script).catch(err => {
                                        console.log('Focus script failed (expected during initialization):', err.message);
                                    });
                                }, 100);
                            }
                        }
                    } catch (error) {
                        console.error('Error in dom-ready handler:', error);
                    }
                });

                // Handle messages coming from newtab.html via ipcRenderer.sendToHost
                webview.addEventListener('ipc-message', (event) => {
                    try {
                        if (!event || !event.channel) return;
                        const channel = event.channel;
                        const arg = (event.args && event.args[0]) || {};
                        if (channel === 'request-tabs') {
                            const tabData = this.tabs
                                .filter(t => t.id !== tab.id && !t.url.includes('newtab.html'))
                                .map(t => ({ id: t.id, title: t.title, url: t.url }));
                            try {
                                webview.send('guest-message', { type: 'tabs-response', tabs: tabData });
                            } catch (err) {
                                console.error('Failed to send tabs response (ipc):', err);
                            }
                        }
                        if (channel === 'new-tab-chat-send') {
                            const data = { type: 'new-tab-chat-send', ...arg };
                            this.handleNewTabChat(data, tab);
                        }
                        if (channel === 'shortcut') {
                            switch (arg.command) {
                                case 'close-tab':
                                    this.closeTab(tab.id);
                                    break;
                                case 'new-tab':
                                    this.createTab().then(newTab => {
                                        if (newTab && newTab.url && newTab.url.includes('newtab.html')) {
                                            this.ensureNewTabFocus(newTab);
                                        }
                                    });
                                    break;
                                case 'focus-url':
                                    if (!this.urlBarContainer || this.urlBarContainer.style.display !== 'none') {
                                        this.urlBar.focus();
                                    }
                                    break;
                                case 'refresh-page':
                                    this.refreshPage();
                                    break;
                                case 'toggle-chat':
                                    this.toggleChatSidebar();
                                    break;
                                default:
                                    break;
                            }
                        }
                    } catch (e) {
                        console.error('ipc-message handler error:', e);
                    }
                });

                webview.addEventListener('page-title-updated', (_event) => {
                    const newTitle = webview.getTitle() || 'New Tab';
                    tab.title = newTitle;
                    tabTitle.textContent = newTitle;
                    tabTitle.setAttribute('title', newTitle);
                    if (tab.railTitle) {
                        tab.railTitle.textContent = newTitle;
                        tab.railTitle.setAttribute('title', newTitle);
                    }
                });
                // Add listener to capture page favicon changes
                webview.addEventListener('page-favicon-updated', async (event) => {
                    if (event.favicons && event.favicons.length > 0) {
                        tabFavicon.src = event.favicons[0];
                        if (tab.railFavicon) tab.railFavicon.src = event.favicons[0];
                    } else {
                        // If favicon still empty, attempt fallback
                        await updateFaviconFallback();
                    }
                });

                webview.addEventListener('did-navigate', (e) => {
                    tab.url = e.url;
                    // Clear favicon when navigating to new main page
                    tabFavicon.src = '';
                    if (tab.railFavicon) tab.railFavicon.src = '';
                    if (this.activeTabId === tabId) {
                        this.urlBar.value = e.url;
                        this.updateNavBarVisibility(e.url);
                    }
                });

                webview.addEventListener('did-navigate-in-page', (e) => {
                    tab.url = e.url;
                    // Clear favicon for in-page navigations too (e.g., SPA route changes)
                    tabFavicon.src = '';
                    if (tab.railFavicon) tab.railFavicon.src = '';
                    if (this.activeTabId === tabId) {
                        this.urlBar.value = e.url;
                        this.updateNavBarVisibility(e.url);
                    }
                });

                webview.addEventListener('did-fail-load', (e) => {
                    console.error('Page failed to load:', e);
                    if (e.errorCode !== -3 && this.activeTabId === tabId) { 
                        this.showError();
                    }
                    tab.isLoading = false;
                });

                webview.addEventListener('did-start-loading', () => {
                    tab.isLoading = true;
                    tabTitle.textContent = 'Loading...';
                    if (tab.railTitle) tab.railTitle.textContent = 'Loading...';
                    // Removed favicon reset here to avoid flicker; handled on navigation
                    if (this.activeTabId === tabId) {
                        this.showLoading();
                    }
                });

                webview.addEventListener('did-stop-loading', async () => {
                    tab.isLoading = false;
                    const finalTitle = webview.getTitle() || tab.title;
                    tab.title = finalTitle;
                    tabTitle.textContent = finalTitle;
                    tabTitle.setAttribute('title', finalTitle);
                    if (tab.railTitle) {
                        tab.railTitle.textContent = finalTitle;
                        tab.railTitle.setAttribute('title', finalTitle);
                    }
                    // If favicon still empty, attempt fallback
                    if (!tabFavicon.src) {
                        await updateFaviconFallback();
                    }
                    if (this.activeTabId === tabId) {
                        this.hideLoading();
                    }
                });

                this.contentArea.appendChild(webview);
                tab.webview = webview;
                tab.tabElement = tabElement;
                tab.tabTitle = tabTitle;

                this.tabs.push(tab);
                // Initialize empty chat session for this tab
                if (!this.chatSessions.has(tabId)) {
                    this.chatSessions.set(tabId, []);
                }

                // When the webview is ready, perform the full switch if it's the active tab.
                // This prevents race conditions where we try to execute JS before the page is loaded.
                webview.addEventListener('dom-ready', () => {
                    if (this.activeTabId === tabId) {
                        this.switchToTab(tabId);
                    }
                }, { once: true });

                // Always focus the newly created tab
                this.switchToTab(tabId);

                return tab;
            }

            showLoading() {
                this.loadingState.style.display = 'flex';
                this.errorState.style.display = 'none';
            }

            hideLoading() {
                this.loadingState.style.display = 'none';
            }

            showError() {
                this.loadingState.style.display = 'none';
                this.errorState.style.display = 'flex';
            }

            createInitialTab() {
                console.log('createInitialTab called');
                this.createTab('newtab.html');
            }

            switchToTab(tabId) {
                // Hide all webviews and deactivate tabs
                this.tabs.forEach(tab => {
                    tab.webview.style.display = 'none';
                    tab.tabElement.classList.remove('active');
                    tab.tabElement.setAttribute('aria-selected', 'false');
                    if (tab.railElement) {
                        tab.railElement.classList.remove('active');
                        tab.railElement.setAttribute('aria-selected', 'false');
                    }
                });

                // Show selected webview and activate tab
                const tab = this.tabs.find(t => t.id === tabId);
                if (tab) {
                    tab.webview.style.display = 'flex';
                    tab.tabElement.classList.add('active');
                    tab.tabElement.setAttribute('aria-selected', 'true');
                    if (tab.railElement) {
                        tab.railElement.classList.add('active');
                        tab.railElement.setAttribute('aria-selected', 'true');
                    }
                    this.activeTabId = tabId;
                    this.urlBar.value = tab.url;
                    this.updateNavBarVisibility(tab.url);

                    if (tab.url && tab.url.includes('newtab.html')) {
                        this.hideChatSidebar(true); // Hide and clear for newtab
                        if (tab.webview) {
                            tab.webview.focus();
                            const script = '(() => { const el = document.getElementById("searchInput"); if (el) { el.focus(); if (el.select) el.select(); } })()';
                            tab.webview.executeJavaScript(script).catch(err => {
                                console.log('Focus script failed:', err.message);
                            });
                        }
                    } else {
                        if (tab.chatSidebarOpen) {
                            this.showChatSidebar();
                        } else {
                            this.hideChatSidebar();
                        }
                    }
                    
                    this.updateChatContextUI(tab);
                    // Focus management
                    if (!this.urlBarContainer || this.urlBarContainer.style.display !== 'none') {
                        this.urlBar.focus();
                    } else if (tab.webview) {
                        tab.webview.focus();
                    }
                    
                    // Guarantee the new-tab search box is focused and selected so shortcuts work without extra clicks
                    if (tab.url && tab.url.includes('newtab.html') && tab.webview) {
                        const script = '(() => { const el = document.getElementById("searchInput"); if (el) { el.focus(); if (el.select) el.select(); } })()';
                        tab.webview.executeJavaScript(script).catch(err => {
                            console.log('Focus script failed:', err.message);
                        });
                    }
                }
            }

            closeTab(tabId) {
                const tabIndex = this.tabs.findIndex(t => t.id === tabId);
                if (tabIndex === -1) return;

                const tab = this.tabs[tabIndex];
                
                // Remove from DOM
                tab.tabElement.remove();
                tab.webview.remove();
                if (tab.railElement) tab.railElement.remove();
                
                // Remove from tabs array
                this.tabs.splice(tabIndex, 1);

                // If this was the active tab, switch to another
                if (this.activeTabId === tabId) {
                    if (this.tabs.length > 0) {
                        const newActiveTab = this.tabs[Math.max(0, tabIndex - 1)];
                        this.switchToTab(newActiveTab.id);
                    } else {
                        // No tabs left, create a new one
                        this.createTab();
                    }
                }
            }

            closeActiveTab() {
                if (this.activeTabId) {
                    this.closeTab(this.activeTabId);
                }
            }

            async navigateToUrl() {
                const url = this.urlBar.value.trim();
                if (!url) return;

                const result = await window.electronAPI.navigateTo(url);
                if (result.success && this.activeTabId) {
                    const tab = this.tabs.find(t => t.id === this.activeTabId);
                    if (tab) {
                        tab.webview.loadURL(result.url);
                        tab.url = result.url;
                    }
                }
            }

            navigateBack() {
                if (this.activeTabId) {
                    const tab = this.tabs.find(t => t.id === this.activeTabId);
                    if (tab && tab.webview.canGoBack()) {
                        tab.webview.goBack();
                    }
                }
            }

            navigateForward() {
                if (this.activeTabId) {
                    const tab = this.tabs.find(t => t.id === this.activeTabId);
                    if (tab && tab.webview.canGoForward()) {
                        tab.webview.goForward();
                    }
                }
            }

            refreshPage() {
                if (this.activeTabId) {
                    const tab = this.tabs.find(t => t.id === this.activeTabId);
                    if (tab) {
                        tab.webview.reload();
                    }
                }
            }

            async handleChatSend() {
                if (!this.chatInput) return;
                const message = this.chatInput.value.trim();
                if (!message) return;
                this.chatInput.value = '';
            
                const tabId = this.activeTabId;
                const session = this.chatSessions.get(tabId) || [];
            
                // Add user message to session and UI
                session.push({ role: 'user', content: message });
                this.renderChatHistory(); // Re-render to show user message
            
                // Get context from all referenced tabs
                const activeTab = this.tabs.find(t => t.id === this.activeTabId);
                const contexts = [];
                
                if (activeTab) {
                    for (const tabId of activeTab.referencedTabs) {
                        const referencedTab = this.tabs.find(t => t.id === tabId);
                        if (referencedTab) {
                            try {
                                const context = await this.getPageContext(referencedTab);
                                if (context) contexts.push(context);
                            } catch (err) {
                                console.error(`Failed to get page context for referenced tab ${tabId}:`, err);
                            }
                        }
                    }
                }

                // Add placeholder for assistant message to session
                const assistantMessage = { role: 'assistant', content: '' };
                session.push(assistantMessage);
                const assistantMessageIndex = session.length - 1;
            
                // Re-render to show assistant placeholder
                this.renderChatHistory();
                this.chatHistory.scrollTop = this.chatHistory.scrollHeight;
            
                // Generate unique request ID and send to main process
                const reqId = Date.now().toString();
                window.electronAPI.sendChat(reqId, session.slice(0, -1), contexts); // Send all contexts
            
                const streamHandler = (data) => {
                    if (data.id !== reqId) return;
            
                    if (data.token) {
                        // Always update the session state in the background
                        assistantMessage.content += data.token;
            
                        // Only update the DOM if the message's tab is active
                        if (this.activeTabId === tabId) {
                            const msgContainer = document.getElementById(`asst-msg-${tabId}-${assistantMessageIndex}`);
                            if (msgContainer) {
                                const contentEl = msgContainer.querySelector('.chat-content');
                                // Update with raw text during stream for performance
                                contentEl.textContent = assistantMessage.content;
                                this.chatHistory.scrollTop = this.chatHistory.scrollHeight;
                            }
                        }
                    } else if (data.done) {
                        // Final state is already in assistantMessage.content
                        // Re-render one last time with markdown if the tab is active
                        if (this.activeTabId === tabId) {
                            const msgContainer = document.getElementById(`asst-msg-${tabId}-${assistantMessageIndex}`);
                            if (msgContainer) {
                                const contentEl = msgContainer.querySelector('.chat-content');
                                contentEl.innerHTML = this.marked.parse(assistantMessage.content);
                            }
                        }
                        window.electronAPI.removeListener('chat-stream', streamHandler);
                    } else if (data.error) {
                        assistantMessage.content = `Error: ${data.error}`;
                        if (this.activeTabId === tabId) {
                            this.renderChatHistory(); // Re-render to show the error
                        }
                        window.electronAPI.removeListener('chat-stream', streamHandler);
                    }
                };
            
                window.electronAPI.onChatStream(streamHandler);
            }

            async handleSummarizePage() {
                const tabId = this.activeTabId;
                const activeTab = this.tabs.find(t => t.id === tabId);
                if (!activeTab || activeTab.url.includes('newtab.html')) {
                    return;
                }

                this.showChatSidebar();

                const session = this.chatSessions.get(tabId) || [];
                session.push({ role: 'user', content: 'Summarize this page.' });

                const assistantMessage = { role: 'assistant', content: '' };
                session.push(assistantMessage);
                const assistantMessageIndex = session.length - 1;

                this.renderChatHistory();
                this.chatHistory.scrollTop = this.chatHistory.scrollHeight;

                const contexts = [];
                try {
                    const context = await this.getPageContext(activeTab);
                    if (context) contexts.push(context);
                } catch (err) {
                    console.error('Failed to get page context for summarization:', err);
                }

                const reqId = Date.now().toString();
                window.electronAPI.sendChat(reqId, session.slice(0, -1), contexts);

                const streamHandler = (data) => {
                    if (data.id !== reqId) return;

                    if (data.token) {
                        assistantMessage.content += data.token;
                        if (this.activeTabId === tabId) {
                            const msgContainer = document.getElementById(`asst-msg-${tabId}-${assistantMessageIndex}`);
                            if (msgContainer) {
                                const contentEl = msgContainer.querySelector('.chat-content');
                                contentEl.textContent = assistantMessage.content;
                                this.chatHistory.scrollTop = this.chatHistory.scrollHeight;
                            }
                        }
                    } else if (data.done) {
                        if (this.activeTabId === tabId) {
                            const msgContainer = document.getElementById(`asst-msg-${tabId}-${assistantMessageIndex}`);
                            if (msgContainer) {
                                const contentEl = msgContainer.querySelector('.chat-content');
                                contentEl.innerHTML = this.marked.parse(assistantMessage.content);
                            }
                        }
                        window.electronAPI.removeListener('chat-stream', streamHandler);
                    } else if (data.error) {
                        assistantMessage.content = `Error: ${data.error}`;
                        if (this.activeTabId === tabId) {
                            this.renderChatHistory();
                        }
                        window.electronAPI.removeListener('chat-stream', streamHandler);
                    }
                };

                window.electronAPI.onChatStream(streamHandler);
            }

            async getPageContext(tab) {
                if (!tab || !tab.webview || tab.isLoading || tab.webview.isCrashed()) {
                    return null;
                }
                const webview = tab.webview;

                try {
                    const pageUrl = webview.getURL();
                    if (!pageUrl.startsWith('http')) {
                        return null;
                    }
                    const pageTitle = webview.getTitle();
                    const pageContent = await webview.executeJavaScript('document.body.innerText');
                    return {
                        title: pageTitle,
                        url: pageUrl,
                        content: pageContent.substring(0, 4000) // Truncate for performance
                    };
                } catch (e) {
                    console.error(`Could not get page context: `, e);
                    return null;
                }
            }


            toggleChatSidebar() {
                if (!this.chatSidebar) return;
                // Prevent opening on new-tab pages
                const currentTab = this.tabs.find(t => t.id === this.activeTabId);
                if (currentTab && currentTab.url && currentTab.url.includes('newtab.html')) {
                    return;
                }
                const isOpen = this.chatSidebar.classList.toggle('open');
                if (currentTab) {
                    currentTab.chatSidebarOpen = isOpen;
                }

                if (isOpen) {
                    this.showChatSidebar();
                } else {
                    this.hideChatSidebar();
                }
            }

            showChatSidebar() {
                if (!this.chatSidebar) return;
                const currentTab = this.tabs.find(t => t.id === this.activeTabId);
                if (!currentTab) return;

                // Auto-add current page as context if it's not a newtab and not already added
                if (!currentTab.url.includes('newtab.html') && !currentTab.referencedTabs.has(currentTab.id)) {
                    currentTab.referencedTabs.add(currentTab.id);
                }
                
                this.chatSidebar.classList.add('open');
                this.updateContentAreaWidth();
                this.chatInput.focus();
                this.renderChatHistory();
                this.updateChatContextUI(currentTab);
                currentTab.chatSidebarOpen = true;
            }

            hideChatSidebar(clearHistory = false) {
                if (!this.chatSidebar) return;
                this.chatSidebar.classList.remove('open');
                this.updateContentAreaWidth();

                const currentTab = this.tabs.find(t => t.id === this.activeTabId);
                if (currentTab) {
                    currentTab.chatSidebarOpen = false;
                }
                if (clearHistory) {
                    this.chatHistory.innerHTML = '';
                }
            }

            updateChatContextUI(tab) {
                this.renderContextPills();
                const hasContext = tab && tab.referencedTabs.size > 0;
                this.chatInput.placeholder = hasContext ? 'Ask a question about the page(s)...' : 'Ask AI...';
            }

            dismissPageContext() {
                // This function is no longer needed as individual pills are dismissed.
            }

            renderChatHistory() {
                if (!this.chatHistory) return;
                this.chatHistory.innerHTML = '';
                const messages = this.chatSessions.get(this.activeTabId) || [];
                messages.forEach((msg, index) => {
                    const wrapper = document.createElement('div');
                    wrapper.className = `chat-msg ${msg.role === 'user' ? 'user-msg' : 'assistant-msg'}`;
                    // Add a unique ID to the assistant message wrapper for easy targeting
                    if (msg.role === 'assistant') {
                        wrapper.id = `asst-msg-${this.activeTabId}-${index}`;
                    }
                    const label = document.createElement('div');
                    label.className = 'chat-label';
                    label.textContent = msg.role === 'user' ? 'You' : 'AI';
                    const content = document.createElement('div');
                    content.className = 'chat-content';
                    if (msg.role === 'assistant') {
                        content.innerHTML = this.marked.parse(msg.content);
                    } else {
                        content.textContent = msg.content;
                    }
                    wrapper.appendChild(label);
                    wrapper.appendChild(content);
                    this.chatHistory.appendChild(wrapper);
                });
                this.chatHistory.scrollTop = this.chatHistory.scrollHeight;
            }

            clearChat() {
                this.chatSessions.set(this.activeTabId, []);
                if (this.chatHistory) {
                    this.chatHistory.innerHTML = '';
                }
                // Also reset the context dismissal state
                const tab = this.tabs.find(t => t.id === this.activeTabId);
                if (tab) {
                    tab.referencedTabs.clear();
                    // Re-add current tab if it's a valid context page
                    if (!tab.url.includes('newtab.html')) {
                        tab.referencedTabs.add(tab.id);
                    }
                    this.updateChatContextUI(tab);
                }
            }

            handleChatInput() {
                const value = this.chatInput.value;
                const atIndex = value.lastIndexOf('@');

                if (atIndex > -1 && (atIndex === 0 || /\s/.test(value[atIndex - 1]))) {
                    const query = value.substring(atIndex + 1);
                    this.showTabSuggestions(query);
                } else {
                    this.hideTabSuggestions();
                }
            }

            handleSuggestionClick(e) {
                const item = e.target.closest('.suggestion-item');
                if (!item) return;

                const tabId = item.getAttribute('data-tab-id');
                const activeTab = this.tabs.find(t => t.id === this.activeTabId);

                if (tabId && activeTab) {
                    activeTab.referencedTabs.add(tabId);
                    this.updateChatContextUI(activeTab);

                    const atIndex = this.chatInput.value.lastIndexOf('@');
                    this.chatInput.value = this.chatInput.value.substring(0, atIndex);
                    this.hideTabSuggestions();
                    this.chatInput.focus();
                }
            }

            showTabSuggestions(query) {
                const activeTab = this.tabs.find(t => t.id === this.activeTabId);
                const filteredTabs = this.tabs.filter(tab =>
                    !activeTab.referencedTabs.has(tab.id) &&
                    (tab.title.toLowerCase().includes(query.toLowerCase()) ||
                     tab.url.toLowerCase().includes(query.toLowerCase()))
                );

                if (filteredTabs.length > 0) {
                    this.tabSuggestions.innerHTML = filteredTabs.map(tab => `
                        <div class="suggestion-item" data-tab-id="${tab.id}">
                            <div class="suggestion-title">${this.escapeHtml(tab.title)}</div>
                            <div class="suggestion-url">${this.escapeHtml(tab.url)}</div>
                        </div>
                    `).join('');
                    this.tabSuggestions.style.display = 'block';
                } else {
                    this.hideTabSuggestions();
                }
            }

            hideTabSuggestions() {
                this.tabSuggestions.style.display = 'none';
                this.tabSuggestions.innerHTML = '';
            }

            escapeHtml(str) {
                return str.replace(/[&<>"']/g, (match) => {
                    return {
                        '&': '&amp;',
                        '<': '&lt;',
                        '>': '&gt;',
                        '"': '&quot;',
                        "'": '&#39;'
                    }[match];
                });
            }

            handleSuggestionKeyboardNav(e) {
                // Future implementation for arrow key navigation
            }

            renderContextPills() {
                this.contextPillsContainer.innerHTML = '';
                const activeTab = this.tabs.find(t => t.id === this.activeTabId);
                if (!activeTab) return;

                for (const tabId of activeTab.referencedTabs) {
                    const tab = this.tabs.find(t => t.id === tabId);
                    if (tab) {
                        const pill = document.createElement('div');
                        pill.className = 'context-pill';
                        pill.innerHTML = `
                            <span class="context-pill-title" title="${this.escapeHtml(tab.title)}">${this.escapeHtml(tab.title)}</span>
                            <button class="context-pill-remove" data-tab-id="${tab.id}">&times;</button>
                        `;
                        this.contextPillsContainer.appendChild(pill);
                    }
                }

                // Add event listeners to remove buttons
                this.contextPillsContainer.querySelectorAll('.context-pill-remove').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        const tabIdToRemove = e.currentTarget.getAttribute('data-tab-id');
                        activeTab.referencedTabs.delete(tabIdToRemove);
                        this.updateChatContextUI(activeTab);
                    });
                });
            }
        }

        // Initialize the browser when the page loads
        document.addEventListener('DOMContentLoaded', () => {
            try {
                new BrowserManager();
            } catch (error) {
                console.error('Error initializing BrowserManager:', error);
            }
        });
    </script>
</body>
</html>
