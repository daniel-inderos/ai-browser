<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>New Tab</title>
    <link rel="icon" type="image/svg+xml" href="favicon-light.svg" media="(prefers-color-scheme: light)">
    <link rel="icon" type="image/svg+xml" href="favicon-dark.svg" media="(prefers-color-scheme: dark)">
    <link rel="stylesheet" href="index.css">
    <!-- Markdown parser -->
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <style>

        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--color-background);
            color: var(--color-text-primary);
            font-size: 14px;
        }

        .container {
            position: absolute;
            top: 0; left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            padding: 1rem;
            transition: padding var(--transition-normal);
        }

        .main-wrapper {
            width: 100%;
            max-width: 600px;
            display: flex;
            flex-direction: column;
            align-items: center;
            transition: max-width var(--transition-normal), transform var(--transition-normal);
        }

        .logo { font-size: 1.5em; font-weight: 300; margin-bottom: 2rem; color: var(--color-text-primary); transition: opacity var(--transition-normal), transform var(--transition-normal), margin var(--transition-normal), height var(--transition-normal); }

        /* --- MODE TOGGLE --- */
        .mode-toggle {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            transition: transform var(--transition-normal), opacity var(--transition-normal);
        }
        .mode-btn { padding: 0.5rem 1rem; border: 1px solid var(--color-border); border-radius: var(--radius-full); background: transparent; color: var(--color-text-tertiary); cursor: pointer; font-size: 0.9rem; transition: all 0.2s ease; }
        .mode-btn.active { background: var(--color-primary); color: var(--color-text-inverse); border-color: var(--color-primary); }

        /* --- SEARCH WRAPPER --- */
        #searchWrapper { width: 100%; }
        #searchForm { width: 100%; position: relative; }
        #searchInput { width: 100%; padding: 1rem 1.5rem; font-size: 1.125rem; border-radius: var(--radius-full); border: 1px solid var(--color-border); background: var(--color-surface-elevated); color: var(--color-text-primary); outline: none; box-sizing: border-box; }
        #searchInput:focus { background: var(--color-surface); border-color: var(--color-border-focus); box-shadow: var(--shadow-focus), var(--shadow-md); }

        /* --- ASK WRAPPER (CHAT UI) --- */
        #askWrapper { width: 100%; max-width: 100%; height: 100vh; display: flex; flex-direction: column; gap: 0; transition: max-width var(--transition-normal), height var(--transition-normal), transform var(--transition-normal); }

        /* Header */
        .ask-header { width: 100%; display: flex; align-items: center; justify-content: space-between; padding: 0 var(--spacing-1); color: var(--color-text-tertiary); font-size: var(--font-size-xs); }
        .ask-badge { display: inline-flex; align-items: center; gap: .4rem; padding: .25rem .6rem; border: 1px solid var(--color-border); border-radius: var(--radius-full); color: var(--color-text-secondary); }
        .ask-actions { display: inline-flex; align-items: center; gap: .5rem; }
        .icon-btn { display: inline-flex; align-items:center; justify-content:center; width: 28px; height: 28px; border: 1px solid var(--color-border); border-radius: var(--radius-full); background: var(--color-surface-elevated); color: var(--color-text-secondary); cursor: pointer; transition: transform .1s ease, background var(--transition-fast), border var(--transition-fast); }
        .icon-btn:hover { background: var(--color-surface-hover); transform: translateY(-1px); }

        /* Chat surface */
        .chat-surface { position: relative; flex: 1; display: flex; flex-direction: column; gap: var(--spacing-3); padding: var(--spacing-4); border: none; border-radius: 0; background: transparent; box-shadow: none; overflow: hidden; height: 100%; }
        .chat-history { flex: 1; overflow-y: auto; padding-right: var(--spacing-2); scroll-behavior: smooth; }
        .chat-history::-webkit-scrollbar { width: 10px; }
        .chat-history::-webkit-scrollbar-thumb { background: var(--color-border); border-radius: 10px; }
        .chat-empty { height: 100%; display: flex; align-items: center; justify-content: center; text-align: center; color: var(--color-text-secondary); }
        .empty-inner { max-width: 520px; display: flex; flex-direction: column; gap: var(--spacing-4); }
        .empty-title { font-size: var(--font-size-xl); color: var(--color-text-primary); font-weight: var(--font-weight-semibold); }
        .empty-prompts { display: flex; flex-wrap: wrap; gap: var(--spacing-2); justify-content: center; }
        .prompt-chip { padding: .45rem .7rem; border: 1px solid var(--color-border); border-radius: var(--radius-full); background: var(--color-surface-elevated); color: var(--color-text-secondary); cursor: pointer; }
        .prompt-chip:hover { background: var(--color-surface-hover); }
        .empty-hint { font-size: var(--font-size-xs); color: var(--color-text-tertiary); }

        /* Message bubbles */
        .chat-msg { display: grid; grid-template-columns: 36px 1fr; gap: var(--spacing-3); margin-bottom: var(--spacing-3); }
        .avatar { width: 36px; height: 36px; border-radius: var(--radius-full); display: flex; align-items:center; justify-content:center; border: none; background: var(--color-surface-elevated); color: var(--color-text-secondary); font-weight: var(--font-weight-semibold); }
        .bubble { padding: var(--spacing-3); border: none; border-radius: var(--radius-lg); background: transparent; box-shadow: none; }
        .user-msg .bubble { background: transparent; }
        .assistant-msg .bubble { background: transparent; }
        .chat-label { display:none; }
        .chat-content { line-height: 1.3; font-size: var(--font-size-sm); }
        .chat-content p { margin: 0; }
        .chat-content p:not(:last-child) { margin-bottom: 0.3rem; }
        .chat-content ul:not(:last-child),
        .chat-content ol:not(:last-child),
        .chat-content blockquote:not(:last-child),
        .chat-content pre:not(:last-child) { margin-bottom: 0.4rem; }
        .chat-content ul, .chat-content ol { margin: 0; padding-top: 0; padding-bottom: 0; }
        .chat-content li { margin: 0; line-height: 1.3; padding: 0; }
        .chat-content ul ul, .chat-content ol ol, .chat-content ul ol, .chat-content ol ul { margin: 0; }
        .chat-content pre { background: var(--color-background-secondary); border: 1px solid var(--color-border); border-radius: var(--radius-md); padding: var(--spacing-3); overflow-x:auto; font-family: var(--font-family-mono); font-size: 12px; position: relative; }
        .copy-code { position:absolute; top:8px; right:8px; font-size: 11px; padding: 4px 8px; border-radius: var(--radius-full); border: 1px solid var(--color-border); background: var(--color-surface-elevated); color: var(--color-text-secondary); cursor: pointer; }
        .copy-code:hover { background: var(--color-surface-hover); }
        .streaming-dot { display:inline-block; width:6px; height:6px; border-radius:50%; background: var(--color-text-secondary); margin-left: 6px; animation: pulse 1.2s infinite; vertical-align: middle; }

        /* Input */
        .chat-input-area { display: flex; flex-direction: column; gap: var(--spacing-2); }
        .context-pills-container { display: flex; gap: var(--spacing-2); margin-bottom: 0; overflow-x: auto; padding-bottom: var(--spacing-1); }
        .context-pill { display: flex; align-items: center; gap: var(--spacing-2); background: var(--color-surface-hover); border-radius: var(--radius-full); padding: var(--spacing-1) var(--spacing-2); font-size: 0.75rem; }
        .context-pill-title { white-space: nowrap; overflow: hidden; text-overflow: ellipsis; max-width: 220px; }
        .context-pill-remove { background: none; border: none; color: var(--color-text-tertiary); cursor: pointer; }
        .chat-input-container { display: flex; align-items: flex-end; gap: var(--spacing-2); }
        .chat-input-wrapper { flex: 1; position: relative; }
        textarea.chat-input { width: 100%; min-height: 44px; max-height: 160px; resize: none; padding: var(--spacing-3) calc(var(--spacing-4) + 2px); background: var(--color-surface-elevated); border: 1px solid var(--color-border); border-radius: var(--radius-lg); font-family: var(--font-family-primary); font-size: var(--font-size-sm); color: var(--color-text-primary); box-shadow: var(--shadow-sm); }
        textarea.chat-input:focus { background: var(--color-surface); border-color: var(--color-border-focus); box-shadow: var(--shadow-focus), var(--shadow-md); }
        .send-area { display:flex; align-items:center; gap:.5rem; }
        .chat-send-btn { background: var(--color-primary); color: var(--color-text-inverse); border: none; border-radius: var(--radius-full); width: 40px; height: 40px; display:flex; align-items:center; justify-content:center; cursor:pointer; box-shadow: var(--shadow-md); }
        .chat-send-btn:disabled { opacity:.5; cursor:not-allowed; box-shadow:none; }
        .chat-stop-btn { display:none; background: var(--color-surface-elevated); color: var(--color-text-secondary); border: 1px solid var(--color-border); border-radius: var(--radius-full); height: 36px; padding: 0 .75rem; cursor: pointer; }
        .tab-suggestions { display: none; position: absolute; bottom: calc(100% + var(--spacing-1)); left: 0; right: 0; background: var(--color-surface); border: 1px solid var(--color-border); border-radius: var(--radius-md); max-height: 220px; overflow-y: auto; z-index: 101; box-shadow: var(--shadow-lg); }
        .suggestion-item { padding: var(--spacing-2) var(--spacing-3); cursor: pointer; }
        .suggestion-item:hover { background: var(--color-surface-hover); }
        .suggestion-title { font-weight: 500; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .suggestion-url { font-size: 0.8rem; color: var(--color-text-tertiary); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }

        /* Expanded Ask mode (full page) */
        body.is-ask-expanded .container {
            padding: 0;
            height: 100vh;
        }
        body.is-ask-expanded .main-wrapper {
            max-width: 100%;
            width: 100%;
            height: 100vh;
            align-items: stretch;
            padding: 0;
        }
        @media (max-width: 1280px) {
            body.is-ask-expanded .main-wrapper { max-width: 100%; }
        }
        body.is-ask-expanded .logo {
            opacity: 0;
            transform: translateY(-6px);
            margin: 0;
            height: 0;
            pointer-events: none;
        }
        body.is-ask-expanded .mode-toggle {
            position: fixed;
            top: 12px;
            left: 12px;
            z-index: 100;
            background: var(--color-surface-elevated);
            padding: 4px;
            border-radius: var(--radius-full);
            border: 1px solid var(--color-border);
            box-shadow: var(--shadow-md);
        }
        body.is-ask-expanded #askWrapper {
            max-width: 100%;
            width: 100%;
            height: 100vh;
            transform: translateZ(0);
        }
        body.is-ask-expanded .chat-surface {
            border-radius: 0;
            height: 100vh;
        }
        @media (prefers-reduced-motion: reduce) {
            .container, .main-wrapper, #askWrapper, .mode-toggle, .logo { transition: none !important; }
        }

    </style>
</head>
<body>
    <div class="container">
        <div class="main-wrapper" id="mainWrapper">
            <div class="logo">AI Browser</div>
            <div class="mode-toggle" id="modeToggle">
                <button id="modeSearch" class="mode-btn active">Search</button>
                <button id="modeAsk" class="mode-btn">Ask</button>
            </div>

            <!-- Search Mode UI -->
            <div id="searchWrapper">
                <form id="searchForm" autocomplete="off">
                    <input id="searchInput" type="text" placeholder="Search or enter website" autofocus />
                </form>
            </div>

            <!-- Ask Mode UI (hidden by default) -->
            <div id="askWrapper" style="display:none;">
                <div class="chat-surface">
                    <div class="chat-history" id="chatHistory" aria-live="polite"></div>
                    <div class="chat-input-area">
                        <div id="contextPillsContainer" class="context-pills-container"></div>
                        <form class="chat-input-container" id="chatInputForm" autocomplete="off">
                            <div class="chat-input-wrapper">
                                <textarea id="chatInput" class="chat-input" placeholder="Ask a question..." rows="1"></textarea>
                                <div id="tabSuggestions" class="tab-suggestions"></div>
                            </div>
                            <div class="send-area">
                                <button type="button" class="chat-stop-btn" id="chatStopBtn">Stop</button>
                                <button type="submit" class="chat-send-btn" id="chatSendBtn" aria-label="Send message" disabled>
                                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="22" y1="2" x2="11" y2="13" /><polygon points="22 2 15 22 11 13 2 9 22 2" /></svg>
                                </button>
                            </div>
                        </form>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        class NewTabManager {
            constructor() {
                this.elements = {
                    modeSearch: document.getElementById('modeSearch'),
                    modeAsk: document.getElementById('modeAsk'),
                    searchWrapper: document.getElementById('searchWrapper'),
                    askWrapper: document.getElementById('askWrapper'),
                    searchInput: document.getElementById('searchInput'),
                    searchForm: document.getElementById('searchForm'),
                };
                this.mode = 'search';
                this.askManager = null;
                this.autoSendQuery = null;
                this.pendingChatId = null;
                this.setupEventListeners();
                
                // Check if we should open in Ask mode based on URL parameter
                const urlParams = new URLSearchParams(window.location.search);
                const chatIdParam = urlParams.get('chatId');
                const queryParam = urlParams.get('query');
                const forceAskMode = urlParams.get('mode') === 'ask' || !!chatIdParam || !!queryParam;

                // Prioritize chatId over query - if chatId exists, load saved chat instead of re-executing query
                if (chatIdParam) {
                    this.pendingChatId = chatIdParam;
                    // Clear query param if chatId exists to prevent re-execution
                    if (queryParam) {
                        const newUrl = new URL(window.location);
                        newUrl.searchParams.delete('query');
                        window.history.replaceState({}, '', newUrl);
                    }
                } else if (queryParam) {
                    // Only auto-send query if no chatId exists
                    this.autoSendQuery = queryParam;
                }

                if (forceAskMode) {
                    const modeToggle = document.getElementById('modeToggle');
                    if (modeToggle) {
                        modeToggle.style.display = 'none';
                    }
                    this.switchMode('ask');
                }
            }

            setupEventListeners() {
                this.elements.modeSearch.addEventListener('click', () => this.switchMode('search'));
                this.elements.modeAsk.addEventListener('click', () => this.switchMode('ask'));
                this.elements.searchForm.addEventListener('submit', (e) => {
                    e.preventDefault();
                    this.handleSearch();
                });

                // Forward common browser shortcuts to host so they work immediately
                window.addEventListener('keydown', (e) => {
                    if (!(e.metaKey || e.ctrlKey)) return;
                    const k = e.key.toLowerCase();
                    switch (k) {
                        case 't': // New tab
                            e.preventDefault();
                            this.sendShortcut('new-tab');
                            break;
                        case 'w': // Close tab
                            e.preventDefault();
                            this.sendShortcut('close-tab');
                            break;
                        case 'r': // Refresh
                            e.preventDefault();
                            this.sendShortcut('refresh-page');
                            break;
                        case 'l': // Focus URL bar in host
                            e.preventDefault();
                            this.sendShortcut('focus-url');
                            break;
                        case 'e': // Toggle chat sidebar in host
                            e.preventDefault();
                            this.sendShortcut('toggle-chat');
                            break;
                        default:
                            break;
                    }
                });
            }

            sendShortcut(command) {
                if (window.electronAPI && window.electronAPI.sendToHost) {
                    window.electronAPI.sendToHost('shortcut', { command });
                }
            }

            switchMode(newMode) {
                if (this.mode === newMode && !(newMode === 'ask' && this.pendingChatId)) return;
                this.mode = newMode;

                const isSearch = newMode === 'search';
                this.elements.modeSearch.classList.toggle('active', isSearch);
                this.elements.modeAsk.classList.toggle('active', !isSearch);
                this.elements.searchWrapper.style.display = isSearch ? 'block' : 'none';
                this.elements.askWrapper.style.display = isSearch ? 'none' : 'flex';

                if (isSearch) {
                    document.body.classList.remove('is-ask-expanded');
                    this.elements.searchInput.focus();
                } else {
                    if (!this.askManager) {
                        this.askManager = new AskManager({
                            autoSendQuery: this.autoSendQuery,
                            preloadChatId: this.pendingChatId
                        });
                    } else if (this.pendingChatId) {
                        this.askManager.restoreChatFromId(this.pendingChatId);
                    }
                    this.pendingChatId = null;
                    // Expand to full-page Ask with a smooth animation
                    // Use rAF to ensure class toggle animates cleanly
                    requestAnimationFrame(() => document.body.classList.add('is-ask-expanded'));
                    this.askManager.elements.chatInput.focus();
                }
            }

            handleSearch() {
                const value = this.elements.searchInput.value.trim();
                if (!value) return;
                let target = value;
                if (!/^https?:\/\//i.test(value)) {
                    target = value.includes('.') && !value.includes(' ')
                        ? 'https://' + value
                        : 'https://www.google.com/search?q=' + encodeURIComponent(value);
                }
                window.location.href = target;
            }
        }

        class AskManager {
            constructor({ autoSendQuery = null, preloadChatId = null } = {}) {
                this.elements = {
                    chatHistory: document.getElementById('chatHistory'),
                    contextPillsContainer: document.getElementById('contextPillsContainer'),
                    chatInputForm: document.getElementById('chatInputForm'),
                    chatInput: document.getElementById('chatInput'),
                    tabSuggestions: document.getElementById('tabSuggestions'),
                    chatSendBtn: document.getElementById('chatSendBtn'),
                    chatStopBtn: document.getElementById('chatStopBtn'),
                };
                this.session = [];
                this.referencedTabs = new Set();
                this.allTabs = [];
                this.currentStream = null;
                this.marked = window.marked;
                // Generate unique session ID for this chat
                this.sessionId = 'newtab-' + Date.now();
                this.setupEventListeners();
                this.renderEmptyState();
                
                // Auto-send query if provided
                if (autoSendQuery) {
                    setTimeout(() => {
                        this.elements.chatInput.value = autoSendQuery;
                        this.elements.chatSendBtn.disabled = false;
                        this.handleChatSend();
                    }, 200);
                }

                if (preloadChatId) {
                    this.restoreChatFromId(preloadChatId);
                }
            }

            setupEventListeners() {
                this.elements.chatInputForm.addEventListener('submit', (e) => {
                    e.preventDefault();
                    this.handleChatSend();
                });
                this.elements.chatInput.addEventListener('input', () => this.onEditorInput());
                this.elements.chatInput.addEventListener('keydown', (e) => this.onEditorKeydown(e));
                this.elements.tabSuggestions.addEventListener('click', (e) => this.handleSuggestionClick(e));
                this.elements.chatStopBtn.addEventListener('click', () => this.stopStreaming());
                window.addEventListener('message', (e) => this.handleHostMessage(e));
                if (window.electronAPI && window.electronAPI.onFromHost) {
                    window.electronAPI.onFromHost((data) => this.handleHostMessage({ data }));
                }
                // Cancel any active requests when page is unloading (tab closing)
                window.addEventListener('beforeunload', () => {
                    this.stopStreaming();
                });
            }
            
            handleHostMessage({ data }) {
                if (!data || !data.type) return;
                switch (data.type) {
                    case 'tabs-response':
                        this.allTabs = data.tabs || [];
                        this.renderTabSuggestions(this.elements.chatInput.value);
                        break;
                    case 'chat-stream-response':
                        this.handleStreamResponse(data);
                        break;
                    case 'load-chat-session':
                        this.loadSavedSession(data);
                        break;
                }
            }

            handleChatSend() {
                const content = this.elements.chatInput.value.trim();
                if (!content) return;
                this.elements.chatInput.value = '';
                this.autoResizeEditor();
                this.elements.chatSendBtn.disabled = true;

                this.session.push({ role: 'user', content });
                // Don't add assistant message to session yet - we'll add it when we start receiving tokens
                // This prevents showing an empty assistant message alongside the status indicator
                let assistantMsg = null;
                let assistantIndex = -1;
                
                this.renderChatHistory();

                // Update document title with first message
                if (this.session.filter(m => m.role === 'user').length === 1) {
                    const chatTitle = content.substring(0, 50);
                    document.title = chatTitle;
                    // Send IPC message to update parent tab title and URL bar
                    if (window.electronAPI && window.electronAPI.sendToHost) {
                        window.electronAPI.sendToHost('update-title', { title: chatTitle });
                    }
                }

                const reqId = Date.now().toString();
                this.currentStream = { id: reqId, assistantIndex: -1 }; // Will be set when we add the message
                this.toggleStreamingUI(true);

                // Show status indicator in chat history - start with "Searching the web..." since web search is enabled
                this.showStatusIndicator('Searching the web...');

                const chatData = {
                    reqId,
                    session: this.session, // Send all messages (no assistant placeholder to remove)
                    referencedTabIds: [...this.referencedTabs]
                };
                console.log('NewTab: sendToHost new-tab-chat-send:', chatData);
                if (window.electronAPI && window.electronAPI.sendToHost) {
                    window.electronAPI.sendToHost('new-tab-chat-send', chatData);
                }
            }

            handleStreamResponse(data) {
                if (!this.currentStream || data.id !== this.currentStream.id) return;
                
                // Get or create assistant message
                let assistantMsg = null;
                if (this.currentStream.assistantIndex >= 0) {
                    assistantMsg = this.session[this.currentStream.assistantIndex];
                }
                
                // Add assistant message to session when we receive first token
                if (!assistantMsg && data.token) {
                    assistantMsg = { role: 'assistant', content: '' };
                    this.session.push(assistantMsg);
                    const assistantIndex = this.session.length - 1;
                    this.currentStream.assistantIndex = assistantIndex;
                    // Hide status indicator and render the actual assistant message
                    this.hideStatusIndicator();
                    this.renderChatHistory();
                }
                
                if (assistantMsg && data.token) {
                    // Update status to "Generating..." once we start receiving tokens (if still showing)
                    this.updateStatusIndicator('Generating...');
                    
                    assistantMsg.content += data.token;
                    this.updateAssistantMessage(assistantMsg.content, false);
                }
                if (assistantMsg && data.metadata) {
                    // Store metadata (sources, citations) in the assistant message
                    if (!assistantMsg.metadata) {
                        assistantMsg.metadata = {};
                    }
                    if (data.metadata.sources) {
                        assistantMsg.metadata.sources = data.metadata.sources;
                    }
                    if (data.metadata.citations) {
                        assistantMsg.metadata.citations = data.metadata.citations;
                    }
                }
                if (assistantMsg && (data.done || data.error)) {
                    if(data.error) assistantMsg.content = `Error: ${data.error}`;
                    // Store final metadata if present
                    if (data.sources) {
                        if (!assistantMsg.metadata) assistantMsg.metadata = {};
                        assistantMsg.metadata.sources = data.sources;
                    }
                    if (data.citations) {
                        if (!assistantMsg.metadata) assistantMsg.metadata = {};
                        assistantMsg.metadata.citations = data.citations;
                    }
                    this.updateAssistantMessage(assistantMsg.content, true);
                    // Render citations if available
                    const msgEls = this.elements.chatHistory.querySelectorAll('.assistant-msg');
                    const lastMsgEl = msgEls[msgEls.length - 1];
                    if (lastMsgEl && assistantMsg.metadata) {
                        this.renderCitations(lastMsgEl, assistantMsg.metadata);
                    }
                    
                    // Hide status indicator when done
                    this.hideStatusIndicator();
                    
                    this.currentStream = null;
                    this.toggleStreamingUI(false);
                    // Save chat session after completion
                    this.saveChatSession();
                }
            }
            
            updateAssistantMessage(content, isFinal) {
                const msgEls = this.elements.chatHistory.querySelectorAll('.assistant-msg');
                const lastMsgEl = msgEls[msgEls.length - 1];
                if (lastMsgEl) {
                    const contentEl = lastMsgEl.querySelector('.chat-content');
                    contentEl.innerHTML = isFinal ? this.marked.parse(content) : content.replace(/[&<>"']/g, (m) => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;','\'':'&#39;'}[m]));
                    this.decorateCodeBlocks(lastMsgEl);
                    if (!isFinal) {
                        this.ensureStreamingDot(lastMsgEl);
                    } else {
                        this.removeStreamingDot(lastMsgEl);
                    }
                    this.elements.chatHistory.scrollTop = this.elements.chatHistory.scrollHeight;
                }
            }

            renderChatHistory() {
                if (this.session.length === 0) {
                    this.renderEmptyState();
                    return;
                }
                this.elements.chatHistory.innerHTML = this.session.map((msg, index) => {
                    const safe = (s) => (s || '').replace(/[&<>"']/g, (m) => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;','\'':'&#39;'}[m]));
                    const content = msg.role === 'assistant' ? this.marked.parse(msg.content || '') : safe(msg.content || '');
                    const avatar = msg.role === 'user' ? 'You' : 'AI';
                    const citationsHtml = msg.role === 'assistant' && msg.metadata ? this.renderCitationsHtml(msg.metadata) : '';
                    return `
                        <div class="chat-msg ${msg.role}-msg">
                            <div class="avatar">${avatar}</div>
                            <div class="bubble">
                                <div class="chat-content">${content}</div>
                                ${citationsHtml}
                            </div>
                        </div>`;
                }).join('');
                // Add copy buttons to any code blocks
                this.elements.chatHistory.querySelectorAll('.assistant-msg').forEach(wrapper => this.decorateCodeBlocks(wrapper));
                this.elements.chatHistory.scrollTop = this.elements.chatHistory.scrollHeight;
            }

            renderCitationsHtml(metadata) {
                if (!metadata) return '';
                
                const citations = metadata.citations || [];
                const sources = metadata.sources || [];
                
                if (citations.length === 0 && sources.length === 0) return '';
                
                let html = '<div class="chat-citations">';
                
                // Render citations
                if (citations.length > 0) {
                    const uniqueCitations = new Map();
                    citations.forEach(citation => {
                        if (citation.url && !uniqueCitations.has(citation.url)) {
                            uniqueCitations.set(citation.url, citation);
                        }
                    });
                    
                    html += '<div class="citations-title">Sources:</div><div class="citations-list">';
                    uniqueCitations.forEach(citation => {
                        const title = this.escapeHtml(citation.title || citation.url);
                        const url = this.escapeHtml(citation.url);
                        html += `<a href="${url}" class="citation-item" target="_blank" rel="noopener noreferrer" title="${url}">${title}</a>`;
                    });
                    html += '</div>';
                }
                
                // Render sources
                if (sources.length > 0 && sources.length > (metadata.citations?.length || 0)) {
                    html += '<div class="sources-title">All sources consulted:</div><div class="sources-list">';
                    sources.forEach(source => {
                        if (typeof source === 'string') {
                            const escapedSource = this.escapeHtml(source);
                            html += `<a href="${escapedSource}" class="source-item" target="_blank" rel="noopener noreferrer">${escapedSource}</a>`;
                        }
                    });
                    html += '</div>';
                }
                
                html += '</div>';
                return html;
            }

            renderCitations(msgContainer, metadata) {
                if (!metadata || !msgContainer) return;
                
                // Remove existing citations container if present
                const existingCitations = msgContainer.querySelector('.chat-citations');
                if (existingCitations) {
                    existingCitations.remove();
                }
                
                const citationsHtml = this.renderCitationsHtml(metadata);
                if (citationsHtml) {
                    const bubble = msgContainer.querySelector('.bubble');
                    if (bubble) {
                        bubble.insertAdjacentHTML('beforeend', citationsHtml);
                    }
                }
            }

            handleChatInput() {
                const value = this.elements.chatInput.value;
                const atIndex = value.lastIndexOf('@');
                if (atIndex > -1 && (atIndex === 0 || /\s/.test(value[atIndex - 1]))) {
                    console.log('NewTab: sendToHost request-tabs');
                    if (window.electronAPI && window.electronAPI.sendToHost) {
                        window.electronAPI.sendToHost('request-tabs', {});
                    }
                    this.renderTabSuggestions(value);
                } else {
                    this.hideTabSuggestions();
                }
            }

            renderTabSuggestions(value) {
                const query = value.substring(value.lastIndexOf('@') + 1).toLowerCase();
                const availableTabs = this.allTabs.filter(t => !this.referencedTabs.has(t.id));
                const filtered = query
                    ? availableTabs.filter(t => t.title.toLowerCase().includes(query) || t.url.toLowerCase().includes(query))
                    : availableTabs;

                if (filtered.length > 0) {
                    this.elements.tabSuggestions.innerHTML = filtered.map(tab => {
                        const displayTitle = this.getTabLabel(tab);
                        return `
                        <div class="suggestion-item" data-tab-id="${tab.id}" data-tab-title="${this.escapeHtml(displayTitle)}">
                            <div class="suggestion-title">${this.escapeHtml(displayTitle)}</div>
                            <div class="suggestion-url">${this.escapeHtml(tab.url)}</div>
                        </div>`;
                    }).join('');
                    this.elements.tabSuggestions.style.display = 'block';
                } else {
                    this.hideTabSuggestions();
                }
            }

            getTabLabel(tab) {
                if (!tab) {
                    return 'Untitled tab';
                }

                const title = (tab.title || '').trim();
                const url = tab.url || '';

                if (url.includes('newtab.html')) {
                    return 'AI Chat';
                }
                if (url.includes('history.html')) {
                    return 'History';
                }
                if (url.includes('settings.html')) {
                    return 'Settings';
                }

                if (title && !title.startsWith('file://')) {
                    return title;
                }

                if (url) {
                    try {
                        const parsed = new URL(url);
                        if (parsed.protocol === 'file:') {
                            const segments = parsed.pathname.split('/').filter(Boolean);
                            const fileName = segments.pop();
                            if (fileName) {
                                return fileName;
                            }
                        }
                    } catch (err) {
                        // ignore parsing errors
                    }
                }

                if (title) {
                    return title;
                }

                return url || 'Untitled tab';
            }
            
            handleSuggestionClick(e) {
                const item = e.target.closest('.suggestion-item');
                if (!item) return;

                const tabId = item.getAttribute('data-tab-id');
                const tabTitle = item.getAttribute('data-tab-title');
                this.referencedTabs.add(tabId);
                this.renderContextPills();
                this.updatePlaceholder();
                
                const atIndex = this.elements.chatInput.value.lastIndexOf('@');
                this.elements.chatInput.value = this.elements.chatInput.value.substring(0, atIndex);
                this.hideTabSuggestions();
                this.elements.chatInput.focus();
            }

            renderContextPills() {
                this.elements.contextPillsContainer.innerHTML = '';
                this.referencedTabs.forEach(tabId => {
                    const tab = this.allTabs.find(t => t.id === tabId);
                    const pill = document.createElement('div');
                    pill.className = 'context-pill';
                    const displayTitle = this.getTabLabel(tab);
                    pill.innerHTML = `
                        <span class="context-pill-title" title="${this.escapeHtml(displayTitle)}">${this.escapeHtml(displayTitle)}</span>
                        <button class="context-pill-remove" data-tab-id="${tabId}">&times;</button>`;
                    pill.querySelector('.context-pill-remove').addEventListener('click', () => {
                        this.referencedTabs.delete(tabId);
                        this.renderContextPills();
                        this.updatePlaceholder();
                    });
                    this.elements.contextPillsContainer.appendChild(pill);
                });
            }

            showStatusIndicator(text) {
                if (!this.elements.chatHistory) return;
                // Remove existing status indicator if present
                this.hideStatusIndicator();
                // Create new status indicator
                const statusWrapper = document.createElement('div');
                statusWrapper.className = 'chat-msg assistant-msg';
                statusWrapper.id = 'chat-status-indicator-wrapper';
                const avatar = document.createElement('div');
                avatar.className = 'avatar';
                avatar.textContent = 'AI';
                const bubble = document.createElement('div');
                bubble.className = 'bubble';
                const statusContainer = document.createElement('div');
                statusContainer.className = 'chat-status-indicator';
                
                // Add search icon
                const iconSvg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                iconSvg.setAttribute('width', '16');
                iconSvg.setAttribute('height', '16');
                iconSvg.setAttribute('viewBox', '0 0 24 24');
                iconSvg.setAttribute('fill', 'none');
                iconSvg.setAttribute('stroke', 'currentColor');
                iconSvg.setAttribute('stroke-width', '2');
                iconSvg.setAttribute('stroke-linecap', 'round');
                iconSvg.setAttribute('stroke-linejoin', 'round');
                iconSvg.classList.add('chat-status-indicator-icon');
                const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                circle.setAttribute('cx', '11');
                circle.setAttribute('cy', '11');
                circle.setAttribute('r', '8');
                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                path.setAttribute('d', 'm21 21-4.35-4.35');
                iconSvg.appendChild(circle);
                iconSvg.appendChild(path);
                
                const statusText = document.createElement('span');
                statusText.className = 'status-text';
                statusText.textContent = text;
                statusContainer.appendChild(iconSvg);
                statusContainer.appendChild(statusText);
                bubble.appendChild(statusContainer);
                statusWrapper.appendChild(avatar);
                statusWrapper.appendChild(bubble);
                this.elements.chatHistory.appendChild(statusWrapper);
                this.elements.chatHistory.scrollTop = this.elements.chatHistory.scrollHeight;
            }

            updateStatusIndicator(text) {
                if (!this.elements.chatHistory) return;
                const statusWrapper = document.getElementById('chat-status-indicator-wrapper');
                if (statusWrapper) {
                    const statusText = statusWrapper.querySelector('.status-text');
                    if (statusText) {
                        statusText.textContent = text;
                    }
                }
            }

            hideStatusIndicator() {
                if (!this.elements.chatHistory) return;
                const statusWrapper = document.getElementById('chat-status-indicator-wrapper');
                if (statusWrapper) {
                    statusWrapper.remove();
                }
            }

            clearChat() {
                this.session = [];
                this.referencedTabs.clear();
                this.renderChatHistory();
                this.renderContextPills();
                this.updatePlaceholder();
                // Hide status indicator when clearing chat
                this.hideStatusIndicator();
                // Generate new session ID for next chat
                this.sessionId = 'newtab-' + Date.now();
            }

            loadSavedSession(data) {
                if (!data || !Array.isArray(data.session)) {
                    return;
                }

                // Reset current stream state
                this.currentStream = null;
                this.toggleStreamingUI(false);

                this.sessionId = data.chatId || this.sessionId || 'newtab-' + Date.now();
                this.session = data.session.map((msg) => ({ ...msg }));
                this.referencedTabs.clear();
                this.renderContextPills();
                this.renderChatHistory();
                this.updatePlaceholder();

                if (this.elements.chatHistory) {
                    this.elements.chatHistory.scrollTop = this.elements.chatHistory.scrollHeight;
                }

                if (typeof data.title === 'string' && data.title.trim().length > 0) {
                    const safeTitle = data.title.trim();
                    document.title = safeTitle;
                    if (window.electronAPI && typeof window.electronAPI.sendToHost === 'function') {
                        window.electronAPI.sendToHost('update-title', { title: safeTitle });
                    }
                }

                if (this.elements.chatInput) {
                    this.elements.chatInput.value = '';
                    this.autoResizeEditor();
                    this.elements.chatSendBtn.disabled = true;
                    this.elements.chatInput.focus();
                }
            }

            async restoreChatFromId(chatId) {
                if (!chatId) {
                    return;
                }
                if (!window.electronAPI || typeof window.electronAPI.loadChats !== 'function') {
                    console.warn('electronAPI.loadChats unavailable; cannot restore chat.');
                    return;
                }
                try {
                    const chats = await window.electronAPI.loadChats();
                    const chatData = chats ? chats[chatId] : null;
                    if (!chatData || !Array.isArray(chatData.session)) {
                        console.warn('Saved chat not found for chatId:', chatId);
                        // If chat not found, clear the chatId from URL to prevent retry loops
                        const urlParams = new URLSearchParams(window.location.search);
                        if (urlParams.get('chatId') === chatId) {
                            urlParams.delete('chatId');
                            const newUrl = new URL(window.location);
                            newUrl.search = urlParams.toString();
                            window.history.replaceState({}, '', newUrl);
                        }
                        return;
                    }
                    // Set the sessionId to match the chatId so future saves work correctly
                    this.sessionId = chatId;
                    const firstUserMessage = chatData.session.find((msg) => msg.role === 'user');
                    const fallbackTitle = firstUserMessage ? firstUserMessage.content.substring(0, 50) : 'AI Chat Session';
                    this.loadSavedSession({
                        chatId: chatData.id || chatId,
                        title: chatData.title || fallbackTitle,
                        session: chatData.session.map((msg) => ({ ...msg }))
                    });
                } catch (error) {
                    console.error('Error restoring chat session:', error);
                }
            }

            async saveChatSession() {
                try {
                    if (this.session && this.session.length > 0 && window.electronAPI && window.electronAPI.saveChat) {
                        await window.electronAPI.saveChat(this.sessionId, this.session);
                        // Update document title with first message
                        const firstUserMessage = this.session.find(msg => msg.role === 'user');
                        if (firstUserMessage) {
                            const chatTitle = firstUserMessage.content.substring(0, 50);
                            document.title = chatTitle;
                            // Send IPC message to update parent tab title and URL with chatId
                            if (window.electronAPI && window.electronAPI.sendToHost) {
                                window.electronAPI.sendToHost('update-title', { 
                                    title: chatTitle,
                                    chatId: this.sessionId  // Include chatId so parent can update URL
                                });
                            }
                            // Also update the URL directly in this window to ensure it's saved with chatId
                            const urlParams = new URLSearchParams(window.location.search);
                            if (urlParams.get('chatId') !== this.sessionId) {
                                // Remove query param if it exists
                                urlParams.delete('query');
                                // Set chatId
                                urlParams.set('chatId', this.sessionId);
                                urlParams.set('mode', 'ask');
                                const newUrl = new URL(window.location);
                                newUrl.search = urlParams.toString();
                                window.history.replaceState({}, '', newUrl);
                            }
                        }
                    }
                } catch (error) {
                    console.error('Error saving chat session:', error);
                }
            }

            updatePlaceholder() {
                const hasContext = this.referencedTabs.size > 0;
                this.elements.chatInput.placeholder = hasContext ? 'Ask a question about the page(s)...' : 'Ask a question...';
            }

            hideTabSuggestions() { this.elements.tabSuggestions.style.display = 'none'; }
            escapeHtml(str) { return (str || '').replace(/[&<>"']/g, (m) => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;','\'':'&#39;'}[m])); }

            // --- UI Enhancements ---
            renderEmptyState() {
                this.elements.chatHistory.innerHTML = `
                    <div class="chat-empty">
                        <div class="empty-inner">
                            <div class="empty-title">Ask anything</div>
                            <div class="empty-hint">Get answers, summarize pages, and reference tabs with @</div>
                            <div class="empty-prompts" id="quickPrompts"></div>
                        </div>
                    </div>`;
                const prompts = [
                    'Tell me a fun fact',
                    'Whats a good joke?',
                    'Teach me a random word',
                    'Give me a productivity tip',
                    'What happened on this day in history?'
                ];
                const container = this.elements.chatHistory.querySelector('#quickPrompts');
                prompts.forEach(p => {
                    const chip = document.createElement('button');
                    chip.type = 'button';
                    chip.className = 'prompt-chip';
                    chip.textContent = p;
                    chip.addEventListener('click', () => {
                        this.elements.chatInput.value = p;
                        this.autoResizeEditor();
                        this.elements.chatSendBtn.disabled = false;
                        this.elements.chatInput.focus();
                    });
                    container.appendChild(chip);
                });
            }

            onEditorInput() {
                this.autoResizeEditor();
                this.elements.chatSendBtn.disabled = this.elements.chatInput.value.trim().length === 0;
                this.handleChatInput();
            }

            onEditorKeydown(e) {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    this.handleChatSend();
                }
            }

            autoResizeEditor() {
                const ta = this.elements.chatInput;
                ta.style.height = 'auto';
                ta.style.height = Math.min(ta.scrollHeight, 160) + 'px';
            }

            toggleStreamingUI(isStreaming) {
                this.elements.chatStopBtn.style.display = isStreaming ? 'inline-flex' : 'none';
            }

            ensureStreamingDot(wrapper) {
                if (!wrapper.querySelector('.streaming-dot')) {
                    const dot = document.createElement('span');
                    dot.className = 'streaming-dot';
                    const bubble = wrapper.querySelector('.bubble .chat-content');
                    if (bubble) bubble.appendChild(dot);
                }
            }

            removeStreamingDot(wrapper) {
                wrapper.querySelectorAll('.streaming-dot').forEach(el => el.remove());
            }

            stopStreaming() {
                // Cancel the active request
                if (this.currentStream && this.currentStream.id) {
                    if (window.electronAPI && window.electronAPI.cancelChat) {
                        window.electronAPI.cancelChat(this.currentStream.id);
                    }
                }
                // Stop updating UI for current stream
                this.currentStream = null;
                this.toggleStreamingUI(false);
                this.hideStatusIndicator();
            }

            decorateCodeBlocks(wrapper) {
                wrapper.querySelectorAll('pre').forEach(pre => {
                    if (pre.querySelector('.copy-code')) return;
                    const btn = document.createElement('button');
                    btn.type = 'button';
                    btn.className = 'copy-code';
                    btn.textContent = 'Copy';
                    btn.addEventListener('click', async () => {
                        try {
                            const code = pre.innerText;
                            await navigator.clipboard.writeText(code);
                            btn.textContent = 'Copied';
                            setTimeout(() => btn.textContent = 'Copy', 1200);
                        } catch (e) {}
                    });
                    pre.appendChild(btn);
                });
            }

            sendShortcut(command) {
                if (window.electronAPI && window.electronAPI.sendToHost) {
                    window.electronAPI.sendToHost('shortcut', { command });
                }
            }
        }

        document.addEventListener('DOMContentLoaded', () => new NewTabManager());
    </script>
</body>
</html> 
